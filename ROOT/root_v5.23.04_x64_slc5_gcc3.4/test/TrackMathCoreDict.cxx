//
// File generated by rootcint at Thu Apr 23 11:10:24 2009

// Do NOT change. Changes will be lost next time file is generated
//

#include "RConfig.h" //rootcint 4834
#if !defined(R__ACCESS_IN_SYMBOL)
//Break the privacy of classes -- Disabled for the moment
#define private public
#define protected public
#endif

// Since CINT ignores the std namespace, we need to do so in this file.
namespace std {} using namespace std;
#include "TrackMathCoreDict.h"

#include "TCollectionProxyInfo.h"
#include "TClass.h"
#include "TBuffer.h"
#include "TMemberInspector.h"
#include "TError.h"

#ifndef G__ROOT
#define G__ROOT
#endif

#include "RtypesImp.h"
#include "TIsAProxy.h"

// START OF SHADOWS

namespace ROOT {
   namespace Shadow {
      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::TrackD TrackD;
      #else
      class TrackD  {
         public:
         //friend XX;
         typedef void* (*const_iterator)() ;
         ::ROOT::Math::PositionVector3D< ::ROOT::Math::Cartesian3D< double >, ::ROOT::Math::DefaultCoordinateSystemTag > fPos; //
         ::ROOT::Math::LorentzVector< ::ROOT::Math::PxPyPzE4D< double >  > fVec; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::TrackD32 TrackD32;
      #else
      class TrackD32  {
         public:
         //friend XX;
         typedef void* (*const_iterator)() ;
         ::ROOT::Math::PositionVector3D< ::ROOT::Math::Cartesian3D< Double32_t >, ::ROOT::Math::DefaultCoordinateSystemTag > fPos; //
         ::ROOT::Math::LorentzVector< ::ROOT::Math::PxPyPzE4D< Double32_t >  > fVec; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::TrackErrD TrackErrD;
      #else
      class TrackErrD  {
         public:
         //friend XX;
         typedef void* (*const_iterator)() ;
         ::ROOT::Math::PositionVector3D< ::ROOT::Math::Cartesian3D< double >, ::ROOT::Math::DefaultCoordinateSystemTag > fPos; //
         ::ROOT::Math::LorentzVector< ::ROOT::Math::PxPyPzE4D< double >  > fVec; //
         ::ROOT::Math::SMatrix< double, 4, 4, ::ROOT::Math::MatRepStd< double, 4, 4 >  > fMat; //
         ::ROOT::Math::SMatrix< double, 6, 6, ::ROOT::Math::MatRepSym< double, 6 >  > fSymMat; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::TrackErrD32 TrackErrD32;
      #else
      class TrackErrD32  {
         public:
         //friend XX;
         typedef void* (*const_iterator)() ;
         ::ROOT::Math::PositionVector3D< ::ROOT::Math::Cartesian3D< Double32_t >, ::ROOT::Math::DefaultCoordinateSystemTag > fPos; //
         ::ROOT::Math::LorentzVector< ::ROOT::Math::PxPyPzE4D< Double32_t >  > fVec; //
         ::ROOT::Math::SMatrix< Double32_t, 4, 4, ::ROOT::Math::MatRepStd< Double32_t, 4, 4 >  > fMat; //
         ::ROOT::Math::SMatrix< Double32_t, 6, 6, ::ROOT::Math::MatRepSym< Double32_t, 6 >  > fSymMat; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::VecTrack< ::TrackD > VecTracklETrackDgR;
      #else
      class VecTracklETrackDgR  {
         public:
         //friend XX;
         typedef ::std::vector<TrackD, ::allocator<TrackD> >::iterator It;
         vector< ::TrackD > fTrks; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::VecTrack< ::TrackErrD > VecTracklETrackErrDgR;
      #else
      class VecTracklETrackErrDgR  {
         public:
         //friend XX;
         typedef ::std::vector<TrackErrD, ::allocator<TrackErrD> >::iterator It;
         vector< ::TrackErrD > fTrks; //
      };
      #endif

   } // of namespace Shadow
} // of namespace ROOT
// END OF SHADOWS

namespace ROOT {
   void TrackD_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void TrackD_Dictionary();
   static void *new_TrackD(void *p = 0);
   static void *newArray_TrackD(Long_t size, void *p);
   static void delete_TrackD(void *p);
   static void deleteArray_TrackD(void *p);
   static void destruct_TrackD(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TrackD*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::TrackD) == sizeof(::ROOT::Shadow::TrackD));
      ::TrackD *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::TrackD),0);
      static ::ROOT::TGenericClassInfo 
         instance("TrackD", "TrackMathCore.h", 36,
                  typeid(::TrackD), DefineBehavior(ptr, ptr),
                  (void*)&TrackD_ShowMembers, &TrackD_Dictionary, isa_proxy, 4,
                  sizeof(::TrackD) );
      instance.SetNew(&new_TrackD);
      instance.SetNewArray(&newArray_TrackD);
      instance.SetDelete(&delete_TrackD);
      instance.SetDeleteArray(&deleteArray_TrackD);
      instance.SetDestructor(&destruct_TrackD);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TrackD*)
   {
      return GenerateInitInstanceLocal((::TrackD*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::TrackD*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void TrackD_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::TrackD*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void TrackD32_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void TrackD32_Dictionary();
   static void *new_TrackD32(void *p = 0);
   static void *newArray_TrackD32(Long_t size, void *p);
   static void delete_TrackD32(void *p);
   static void deleteArray_TrackD32(void *p);
   static void destruct_TrackD32(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TrackD32*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::TrackD32) == sizeof(::ROOT::Shadow::TrackD32));
      ::TrackD32 *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::TrackD32),0);
      static ::ROOT::TGenericClassInfo 
         instance("TrackD32", "TrackMathCore.h", 90,
                  typeid(::TrackD32), DefineBehavior(ptr, ptr),
                  (void*)&TrackD32_ShowMembers, &TrackD32_Dictionary, isa_proxy, 4,
                  sizeof(::TrackD32) );
      instance.SetNew(&new_TrackD32);
      instance.SetNewArray(&newArray_TrackD32);
      instance.SetDelete(&delete_TrackD32);
      instance.SetDeleteArray(&deleteArray_TrackD32);
      instance.SetDestructor(&destruct_TrackD32);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TrackD32*)
   {
      return GenerateInitInstanceLocal((::TrackD32*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::TrackD32*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void TrackD32_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::TrackD32*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void TrackErrD_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void TrackErrD_Dictionary();
   static void *new_TrackErrD(void *p = 0);
   static void *newArray_TrackErrD(Long_t size, void *p);
   static void delete_TrackErrD(void *p);
   static void deleteArray_TrackErrD(void *p);
   static void destruct_TrackErrD(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TrackErrD*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::TrackErrD) == sizeof(::ROOT::Shadow::TrackErrD));
      ::TrackErrD *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::TrackErrD),0);
      static ::ROOT::TGenericClassInfo 
         instance("TrackErrD", "TrackMathCore.h", 147,
                  typeid(::TrackErrD), DefineBehavior(ptr, ptr),
                  (void*)&TrackErrD_ShowMembers, &TrackErrD_Dictionary, isa_proxy, 4,
                  sizeof(::TrackErrD) );
      instance.SetNew(&new_TrackErrD);
      instance.SetNewArray(&newArray_TrackErrD);
      instance.SetDelete(&delete_TrackErrD);
      instance.SetDeleteArray(&deleteArray_TrackErrD);
      instance.SetDestructor(&destruct_TrackErrD);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TrackErrD*)
   {
      return GenerateInitInstanceLocal((::TrackErrD*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::TrackErrD*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void TrackErrD_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::TrackErrD*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void TrackErrD32_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void TrackErrD32_Dictionary();
   static void *new_TrackErrD32(void *p = 0);
   static void *newArray_TrackErrD32(Long_t size, void *p);
   static void delete_TrackErrD32(void *p);
   static void deleteArray_TrackErrD32(void *p);
   static void destruct_TrackErrD32(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::TrackErrD32*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::TrackErrD32) == sizeof(::ROOT::Shadow::TrackErrD32));
      ::TrackErrD32 *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::TrackErrD32),0);
      static ::ROOT::TGenericClassInfo 
         instance("TrackErrD32", "TrackMathCore.h", 215,
                  typeid(::TrackErrD32), DefineBehavior(ptr, ptr),
                  (void*)&TrackErrD32_ShowMembers, &TrackErrD32_Dictionary, isa_proxy, 4,
                  sizeof(::TrackErrD32) );
      instance.SetNew(&new_TrackErrD32);
      instance.SetNewArray(&newArray_TrackErrD32);
      instance.SetDelete(&delete_TrackErrD32);
      instance.SetDeleteArray(&deleteArray_TrackErrD32);
      instance.SetDestructor(&destruct_TrackErrD32);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::TrackErrD32*)
   {
      return GenerateInitInstanceLocal((::TrackErrD32*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::TrackErrD32*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void TrackErrD32_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::TrackErrD32*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void VecTracklETrackDgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void VecTracklETrackDgR_Dictionary();
   static void *new_VecTracklETrackDgR(void *p = 0);
   static void *newArray_VecTracklETrackDgR(Long_t size, void *p);
   static void delete_VecTracklETrackDgR(void *p);
   static void deleteArray_VecTracklETrackDgR(void *p);
   static void destruct_VecTracklETrackDgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::VecTrack<TrackD>*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::VecTrack<TrackD>) == sizeof(::ROOT::Shadow::VecTracklETrackDgR));
      ::VecTrack<TrackD> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::VecTrack<TrackD>),0);
      static ::ROOT::TGenericClassInfo 
         instance("VecTrack<TrackD>", "TrackMathCore.h", 285,
                  typeid(::VecTrack<TrackD>), DefineBehavior(ptr, ptr),
                  (void*)&VecTracklETrackDgR_ShowMembers, &VecTracklETrackDgR_Dictionary, isa_proxy, 4,
                  sizeof(::VecTrack<TrackD>) );
      instance.SetNew(&new_VecTracklETrackDgR);
      instance.SetNewArray(&newArray_VecTracklETrackDgR);
      instance.SetDelete(&delete_VecTracklETrackDgR);
      instance.SetDeleteArray(&deleteArray_VecTracklETrackDgR);
      instance.SetDestructor(&destruct_VecTracklETrackDgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::VecTrack<TrackD>*)
   {
      return GenerateInitInstanceLocal((::VecTrack<TrackD>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::VecTrack<TrackD>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void VecTracklETrackDgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::VecTrack<TrackD>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void VecTracklETrackErrDgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void VecTracklETrackErrDgR_Dictionary();
   static void *new_VecTracklETrackErrDgR(void *p = 0);
   static void *newArray_VecTracklETrackErrDgR(Long_t size, void *p);
   static void delete_VecTracklETrackErrDgR(void *p);
   static void deleteArray_VecTracklETrackErrDgR(void *p);
   static void destruct_VecTracklETrackErrDgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::VecTrack<TrackErrD>*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::VecTrack<TrackErrD>) == sizeof(::ROOT::Shadow::VecTracklETrackErrDgR));
      ::VecTrack<TrackErrD> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::VecTrack<TrackErrD>),0);
      static ::ROOT::TGenericClassInfo 
         instance("VecTrack<TrackErrD>", "TrackMathCore.h", 285,
                  typeid(::VecTrack<TrackErrD>), DefineBehavior(ptr, ptr),
                  (void*)&VecTracklETrackErrDgR_ShowMembers, &VecTracklETrackErrDgR_Dictionary, isa_proxy, 4,
                  sizeof(::VecTrack<TrackErrD>) );
      instance.SetNew(&new_VecTracklETrackErrDgR);
      instance.SetNewArray(&newArray_VecTracklETrackErrDgR);
      instance.SetDelete(&delete_VecTracklETrackErrDgR);
      instance.SetDeleteArray(&deleteArray_VecTracklETrackErrDgR);
      instance.SetDestructor(&destruct_VecTracklETrackErrDgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::VecTrack<TrackErrD>*)
   {
      return GenerateInitInstanceLocal((::VecTrack<TrackErrD>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::VecTrack<TrackErrD>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void VecTracklETrackErrDgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::VecTrack<TrackErrD>*)0x0)->GetClass();
   }

} // end of namespace ROOT

//______________________________________________________________________________
namespace ROOT {
   void TrackD_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent)
   {
      // Inspect the data members of an object of class TrackD.
      typedef ::ROOT::Shadow::TrackD ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::TrackD*)0x0)->GetClass();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__parent, "fPos", (void*)&sobj->fPos);
      ::ROOT::GenericShowMembers("Point3D", (void*)&sobj->fPos, R__insp, strcat(R__parent,"fPos."),false);
      R__parent[R__ncp] = 0;
      R__insp.Inspect(R__cl, R__parent, "fVec", (void*)&sobj->fVec);
      ::ROOT::GenericShowMembers("Vector4D", (void*)&sobj->fVec, R__insp, strcat(R__parent,"fVec."),false);
      R__parent[R__ncp] = 0;
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TrackD(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::TrackD : new ::TrackD;
   }
   static void *newArray_TrackD(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::TrackD[nElements] : new ::TrackD[nElements];
   }
   // Wrapper around operator delete
   static void delete_TrackD(void *p) {
      delete ((::TrackD*)p);
   }
   static void deleteArray_TrackD(void *p) {
      delete [] ((::TrackD*)p);
   }
   static void destruct_TrackD(void *p) {
      typedef ::TrackD current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::TrackD

//______________________________________________________________________________
namespace ROOT {
   void TrackD32_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent)
   {
      // Inspect the data members of an object of class TrackD32.
      typedef ::ROOT::Shadow::TrackD32 ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::TrackD32*)0x0)->GetClass();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__parent, "fPos", (void*)&sobj->fPos);
      ::ROOT::GenericShowMembers("Point3D32", (void*)&sobj->fPos, R__insp, strcat(R__parent,"fPos."),false);
      R__parent[R__ncp] = 0;
      R__insp.Inspect(R__cl, R__parent, "fVec", (void*)&sobj->fVec);
      ::ROOT::GenericShowMembers("Vector4D32", (void*)&sobj->fVec, R__insp, strcat(R__parent,"fVec."),false);
      R__parent[R__ncp] = 0;
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TrackD32(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::TrackD32 : new ::TrackD32;
   }
   static void *newArray_TrackD32(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::TrackD32[nElements] : new ::TrackD32[nElements];
   }
   // Wrapper around operator delete
   static void delete_TrackD32(void *p) {
      delete ((::TrackD32*)p);
   }
   static void deleteArray_TrackD32(void *p) {
      delete [] ((::TrackD32*)p);
   }
   static void destruct_TrackD32(void *p) {
      typedef ::TrackD32 current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::TrackD32

//______________________________________________________________________________
namespace ROOT {
   void TrackErrD_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent)
   {
      // Inspect the data members of an object of class TrackErrD.
      typedef ::ROOT::Shadow::TrackErrD ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::TrackErrD*)0x0)->GetClass();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__parent, "fPos", (void*)&sobj->fPos);
      ::ROOT::GenericShowMembers("Point3D", (void*)&sobj->fPos, R__insp, strcat(R__parent,"fPos."),false);
      R__parent[R__ncp] = 0;
      R__insp.Inspect(R__cl, R__parent, "fVec", (void*)&sobj->fVec);
      ::ROOT::GenericShowMembers("Vector4D", (void*)&sobj->fVec, R__insp, strcat(R__parent,"fVec."),false);
      R__parent[R__ncp] = 0;
      R__insp.Inspect(R__cl, R__parent, "fMat", (void*)&sobj->fMat);
      ::ROOT::GenericShowMembers("Matrix4D", (void*)&sobj->fMat, R__insp, strcat(R__parent,"fMat."),false);
      R__parent[R__ncp] = 0;
      R__insp.Inspect(R__cl, R__parent, "fSymMat", (void*)&sobj->fSymMat);
      ::ROOT::GenericShowMembers("SymMatrix6D", (void*)&sobj->fSymMat, R__insp, strcat(R__parent,"fSymMat."),false);
      R__parent[R__ncp] = 0;
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TrackErrD(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::TrackErrD : new ::TrackErrD;
   }
   static void *newArray_TrackErrD(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::TrackErrD[nElements] : new ::TrackErrD[nElements];
   }
   // Wrapper around operator delete
   static void delete_TrackErrD(void *p) {
      delete ((::TrackErrD*)p);
   }
   static void deleteArray_TrackErrD(void *p) {
      delete [] ((::TrackErrD*)p);
   }
   static void destruct_TrackErrD(void *p) {
      typedef ::TrackErrD current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::TrackErrD

//______________________________________________________________________________
namespace ROOT {
   void TrackErrD32_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent)
   {
      // Inspect the data members of an object of class TrackErrD32.
      typedef ::ROOT::Shadow::TrackErrD32 ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::TrackErrD32*)0x0)->GetClass();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__parent, "fPos", (void*)&sobj->fPos);
      ::ROOT::GenericShowMembers("Point3D32", (void*)&sobj->fPos, R__insp, strcat(R__parent,"fPos."),false);
      R__parent[R__ncp] = 0;
      R__insp.Inspect(R__cl, R__parent, "fVec", (void*)&sobj->fVec);
      ::ROOT::GenericShowMembers("Vector4D32", (void*)&sobj->fVec, R__insp, strcat(R__parent,"fVec."),false);
      R__parent[R__ncp] = 0;
      R__insp.Inspect(R__cl, R__parent, "fMat", (void*)&sobj->fMat);
      ::ROOT::GenericShowMembers("Matrix4D32", (void*)&sobj->fMat, R__insp, strcat(R__parent,"fMat."),false);
      R__parent[R__ncp] = 0;
      R__insp.Inspect(R__cl, R__parent, "fSymMat", (void*)&sobj->fSymMat);
      ::ROOT::GenericShowMembers("SymMatrix6D32", (void*)&sobj->fSymMat, R__insp, strcat(R__parent,"fSymMat."),false);
      R__parent[R__ncp] = 0;
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_TrackErrD32(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::TrackErrD32 : new ::TrackErrD32;
   }
   static void *newArray_TrackErrD32(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::TrackErrD32[nElements] : new ::TrackErrD32[nElements];
   }
   // Wrapper around operator delete
   static void delete_TrackErrD32(void *p) {
      delete ((::TrackErrD32*)p);
   }
   static void deleteArray_TrackErrD32(void *p) {
      delete [] ((::TrackErrD32*)p);
   }
   static void destruct_TrackErrD32(void *p) {
      typedef ::TrackErrD32 current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::TrackErrD32

//______________________________________________________________________________
namespace ROOT {
   void VecTracklETrackDgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent)
   {
      // Inspect the data members of an object of class VecTrack<TrackD>.
      typedef ::ROOT::Shadow::VecTracklETrackDgR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::VecTrack<TrackD>*)0x0)->GetClass();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__parent, "fTrks", (void*)&sobj->fTrks);
      ::ROOT::GenericShowMembers("vector<TrackD>", (void*)&sobj->fTrks, R__insp, strcat(R__parent,"fTrks."),false);
      R__parent[R__ncp] = 0;
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_VecTracklETrackDgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::VecTrack<TrackD> : new ::VecTrack<TrackD>;
   }
   static void *newArray_VecTracklETrackDgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::VecTrack<TrackD>[nElements] : new ::VecTrack<TrackD>[nElements];
   }
   // Wrapper around operator delete
   static void delete_VecTracklETrackDgR(void *p) {
      delete ((::VecTrack<TrackD>*)p);
   }
   static void deleteArray_VecTracklETrackDgR(void *p) {
      delete [] ((::VecTrack<TrackD>*)p);
   }
   static void destruct_VecTracklETrackDgR(void *p) {
      typedef ::VecTrack<TrackD> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::VecTrack<TrackD>

//______________________________________________________________________________
namespace ROOT {
   void VecTracklETrackErrDgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent)
   {
      // Inspect the data members of an object of class VecTrack<TrackErrD>.
      typedef ::ROOT::Shadow::VecTracklETrackErrDgR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::VecTrack<TrackErrD>*)0x0)->GetClass();
      Int_t R__ncp = strlen(R__parent);
      if (R__ncp || R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__parent, "fTrks", (void*)&sobj->fTrks);
      ::ROOT::GenericShowMembers("vector<TrackErrD>", (void*)&sobj->fTrks, R__insp, strcat(R__parent,"fTrks."),false);
      R__parent[R__ncp] = 0;
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_VecTracklETrackErrDgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::VecTrack<TrackErrD> : new ::VecTrack<TrackErrD>;
   }
   static void *newArray_VecTracklETrackErrDgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::VecTrack<TrackErrD>[nElements] : new ::VecTrack<TrackErrD>[nElements];
   }
   // Wrapper around operator delete
   static void delete_VecTracklETrackErrDgR(void *p) {
      delete ((::VecTrack<TrackErrD>*)p);
   }
   static void deleteArray_VecTracklETrackErrDgR(void *p) {
      delete [] ((::VecTrack<TrackErrD>*)p);
   }
   static void destruct_VecTracklETrackErrDgR(void *p) {
      typedef ::VecTrack<TrackErrD> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::VecTrack<TrackErrD>

namespace ROOT {
   void vectorlETrackDgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void vectorlETrackDgR_Dictionary();
   static void *new_vectorlETrackDgR(void *p = 0);
   static void *newArray_vectorlETrackDgR(Long_t size, void *p);
   static void delete_vectorlETrackDgR(void *p);
   static void deleteArray_vectorlETrackDgR(void *p);
   static void destruct_vectorlETrackDgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<TrackD>*)
   {
      vector<TrackD> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<TrackD>),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<TrackD>", -2, "prec_stl/vector", 49,
                  typeid(vector<TrackD>), DefineBehavior(ptr, ptr),
                  0, &vectorlETrackDgR_Dictionary, isa_proxy, 4,
                  sizeof(vector<TrackD>) );
      instance.SetNew(&new_vectorlETrackDgR);
      instance.SetNewArray(&newArray_vectorlETrackDgR);
      instance.SetDelete(&delete_vectorlETrackDgR);
      instance.SetDeleteArray(&deleteArray_vectorlETrackDgR);
      instance.SetDestructor(&destruct_vectorlETrackDgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<TrackD> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<TrackD>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlETrackDgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const vector<TrackD>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlETrackDgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<TrackD> : new vector<TrackD>;
   }
   static void *newArray_vectorlETrackDgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<TrackD>[nElements] : new vector<TrackD>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlETrackDgR(void *p) {
      delete ((vector<TrackD>*)p);
   }
   static void deleteArray_vectorlETrackDgR(void *p) {
      delete [] ((vector<TrackD>*)p);
   }
   static void destruct_vectorlETrackDgR(void *p) {
      typedef vector<TrackD> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<TrackD>

namespace ROOT {
   void vectorlETrackErrDgR_ShowMembers(void *obj, TMemberInspector &R__insp, char *R__parent);
   static void vectorlETrackErrDgR_Dictionary();
   static void *new_vectorlETrackErrDgR(void *p = 0);
   static void *newArray_vectorlETrackErrDgR(Long_t size, void *p);
   static void delete_vectorlETrackErrDgR(void *p);
   static void deleteArray_vectorlETrackErrDgR(void *p);
   static void destruct_vectorlETrackErrDgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<TrackErrD>*)
   {
      vector<TrackErrD> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<TrackErrD>),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<TrackErrD>", -2, "prec_stl/vector", 49,
                  typeid(vector<TrackErrD>), DefineBehavior(ptr, ptr),
                  0, &vectorlETrackErrDgR_Dictionary, isa_proxy, 4,
                  sizeof(vector<TrackErrD>) );
      instance.SetNew(&new_vectorlETrackErrDgR);
      instance.SetNewArray(&newArray_vectorlETrackErrDgR);
      instance.SetDelete(&delete_vectorlETrackErrDgR);
      instance.SetDeleteArray(&deleteArray_vectorlETrackErrDgR);
      instance.SetDestructor(&destruct_vectorlETrackErrDgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<TrackErrD> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<TrackErrD>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlETrackErrDgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const vector<TrackErrD>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlETrackErrDgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<TrackErrD> : new vector<TrackErrD>;
   }
   static void *newArray_vectorlETrackErrDgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<TrackErrD>[nElements] : new vector<TrackErrD>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlETrackErrDgR(void *p) {
      delete ((vector<TrackErrD>*)p);
   }
   static void deleteArray_vectorlETrackErrDgR(void *p) {
      delete [] ((vector<TrackErrD>*)p);
   }
   static void destruct_vectorlETrackErrDgR(void *p) {
      typedef vector<TrackErrD> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<TrackErrD>

/********************************************************
* TrackMathCoreDict.cxx
* CAUTION: DON'T CHANGE THIS FILE. THIS FILE IS AUTOMATICALLY GENERATED
*          FROM HEADER FILES LISTED IN G__setup_cpp_environmentXXX().
*          CHANGE THOSE HEADER FILES AND REGENERATE THIS FILE.
********************************************************/

#ifdef G__MEMTEST
#undef malloc
#undef free
#endif

#if defined(__GNUC__) && (__GNUC__ > 3) && (__GNUC_MINOR__ > 1)
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif

extern "C" void G__cpp_reset_tagtableTrackMathCoreDict();

extern "C" void G__set_cpp_environmentTrackMathCoreDict() {
  G__add_compiledheader("TObject.h");
  G__add_compiledheader("TMemberInspector.h");
  G__add_compiledheader("TrackMathCore.h");
  G__cpp_reset_tagtableTrackMathCoreDict();
}
#include <new>
extern "C" int G__cpp_dllrevTrackMathCoreDict() { return(30051515); }

/*********************************************************
* Member function Interface Method
*********************************************************/

/* TrackD */
static int G__TrackMathCoreDict_236_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TrackD* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TrackD[n];
     } else {
       p = new((void*) gvp) TrackD[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TrackD;
     } else {
       p = new((void*) gvp) TrackD;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__TrackMathCoreDictLN_TrackD));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__TrackMathCoreDict_236_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TrackD* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new TrackD((double*) G__int(libp->para[0]), (double*) G__int(libp->para[1]));
   } else {
     p = new((void*) gvp) TrackD((double*) G__int(libp->para[0]), (double*) G__int(libp->para[1]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__TrackMathCoreDictLN_TrackD));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__TrackMathCoreDict_236_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         string* pobj;
         string xobj = TrackD::Type();
         pobj = new string(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__TrackMathCoreDict_236_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) TrackD::IsD32());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__TrackMathCoreDict_236_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const TrackD& obj = ((TrackD*) G__getstructoffset())->operator+=(*(TrackD*) libp->para[0].ref);
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__TrackMathCoreDict_236_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const TrackD*) G__getstructoffset())->Sum());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__TrackMathCoreDict_236_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((const TrackD*) G__getstructoffset())->Print();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__TrackMathCoreDict_236_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   TrackD* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new TrackD(*(TrackD*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__TrackMathCoreDictLN_TrackD));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef TrackD G__TTrackD;
static int G__TrackMathCoreDict_236_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (TrackD*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((TrackD*) (soff+(sizeof(TrackD)*i)))->~G__TTrackD();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (TrackD*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((TrackD*) (soff))->~G__TTrackD();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__TrackMathCoreDict_236_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TrackD* dest = (TrackD*) G__getstructoffset();
   *dest = *(TrackD*) libp->para[0].ref;
   const TrackD& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* TrackD32 */
static int G__TrackMathCoreDict_238_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TrackD32* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TrackD32[n];
     } else {
       p = new((void*) gvp) TrackD32[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TrackD32;
     } else {
       p = new((void*) gvp) TrackD32;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__TrackMathCoreDictLN_TrackD32));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__TrackMathCoreDict_238_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         string* pobj;
         string xobj = TrackD32::Type();
         pobj = new string(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__TrackMathCoreDict_238_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) TrackD32::IsD32());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__TrackMathCoreDict_238_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TrackD32* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new TrackD32((double*) G__int(libp->para[0]), (double*) G__int(libp->para[1]));
   } else {
     p = new((void*) gvp) TrackD32((double*) G__int(libp->para[0]), (double*) G__int(libp->para[1]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__TrackMathCoreDictLN_TrackD32));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__TrackMathCoreDict_238_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const TrackD32& obj = ((TrackD32*) G__getstructoffset())->operator+=(*(TrackD32*) libp->para[0].ref);
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__TrackMathCoreDict_238_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const TrackD32*) G__getstructoffset())->Sum());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__TrackMathCoreDict_238_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((const TrackD32*) G__getstructoffset())->Print();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__TrackMathCoreDict_238_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   TrackD32* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new TrackD32(*(TrackD32*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__TrackMathCoreDictLN_TrackD32));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef TrackD32 G__TTrackD32;
static int G__TrackMathCoreDict_238_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (TrackD32*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((TrackD32*) (soff+(sizeof(TrackD32)*i)))->~G__TTrackD32();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (TrackD32*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((TrackD32*) (soff))->~G__TTrackD32();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__TrackMathCoreDict_238_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TrackD32* dest = (TrackD32*) G__getstructoffset();
   *dest = *(TrackD32*) libp->para[0].ref;
   const TrackD32& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* TrackErrD */
static int G__TrackMathCoreDict_240_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TrackErrD* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TrackErrD[n];
     } else {
       p = new((void*) gvp) TrackErrD[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TrackErrD;
     } else {
       p = new((void*) gvp) TrackErrD;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__TrackMathCoreDictLN_TrackErrD));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__TrackMathCoreDict_240_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TrackErrD* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new TrackErrD((double*) G__int(libp->para[0]), (double*) G__int(libp->para[1]));
   } else {
     p = new((void*) gvp) TrackErrD((double*) G__int(libp->para[0]), (double*) G__int(libp->para[1]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__TrackMathCoreDictLN_TrackErrD));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__TrackMathCoreDict_240_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         string* pobj;
         string xobj = TrackErrD::Type();
         pobj = new string(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__TrackMathCoreDict_240_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) TrackErrD::IsD32());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__TrackMathCoreDict_240_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const TrackErrD& obj = ((TrackErrD*) G__getstructoffset())->operator+=(*(TrackErrD*) libp->para[0].ref);
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__TrackMathCoreDict_240_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const TrackErrD*) G__getstructoffset())->Sum());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__TrackMathCoreDict_240_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((const TrackErrD*) G__getstructoffset())->Print();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__TrackMathCoreDict_240_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   TrackErrD* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new TrackErrD(*(TrackErrD*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__TrackMathCoreDictLN_TrackErrD));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef TrackErrD G__TTrackErrD;
static int G__TrackMathCoreDict_240_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (TrackErrD*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((TrackErrD*) (soff+(sizeof(TrackErrD)*i)))->~G__TTrackErrD();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (TrackErrD*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((TrackErrD*) (soff))->~G__TTrackErrD();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__TrackMathCoreDict_240_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TrackErrD* dest = (TrackErrD*) G__getstructoffset();
   *dest = *(TrackErrD*) libp->para[0].ref;
   const TrackErrD& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* TrackErrD32 */
static int G__TrackMathCoreDict_242_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TrackErrD32* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TrackErrD32[n];
     } else {
       p = new((void*) gvp) TrackErrD32[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new TrackErrD32;
     } else {
       p = new((void*) gvp) TrackErrD32;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__TrackMathCoreDictLN_TrackErrD32));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__TrackMathCoreDict_242_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         string* pobj;
         string xobj = TrackErrD32::Type();
         pobj = new string(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__TrackMathCoreDict_242_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) TrackErrD32::IsD32());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__TrackMathCoreDict_242_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TrackErrD32* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new TrackErrD32((double*) G__int(libp->para[0]), (double*) G__int(libp->para[1]));
   } else {
     p = new((void*) gvp) TrackErrD32((double*) G__int(libp->para[0]), (double*) G__int(libp->para[1]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__TrackMathCoreDictLN_TrackErrD32));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__TrackMathCoreDict_242_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const TrackErrD32& obj = ((TrackErrD32*) G__getstructoffset())->operator+=(*(TrackErrD32*) libp->para[0].ref);
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__TrackMathCoreDict_242_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const TrackErrD32*) G__getstructoffset())->Sum());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__TrackMathCoreDict_242_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((const TrackErrD32*) G__getstructoffset())->Print();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__TrackMathCoreDict_242_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   TrackErrD32* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new TrackErrD32(*(TrackErrD32*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__TrackMathCoreDictLN_TrackErrD32));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef TrackErrD32 G__TTrackErrD32;
static int G__TrackMathCoreDict_242_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (TrackErrD32*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((TrackErrD32*) (soff+(sizeof(TrackErrD32)*i)))->~G__TTrackErrD32();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (TrackErrD32*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((TrackErrD32*) (soff))->~G__TTrackErrD32();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__TrackMathCoreDict_242_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   TrackErrD32* dest = (TrackErrD32*) G__getstructoffset();
   *dest = *(TrackErrD32*) libp->para[0].ref;
   const TrackErrD32& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* VecTrack<TrackD> */
static int G__TrackMathCoreDict_245_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   VecTrack<TrackD>* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new VecTrack<TrackD>[n];
     } else {
       p = new((void*) gvp) VecTrack<TrackD>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new VecTrack<TrackD>;
     } else {
       p = new((void*) gvp) VecTrack<TrackD>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__TrackMathCoreDictLN_VecTracklETrackDgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__TrackMathCoreDict_245_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   VecTrack<TrackD>* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new VecTrack<TrackD>((double*) G__int(libp->para[0]), (double*) G__int(libp->para[1]));
   } else {
     p = new((void*) gvp) VecTrack<TrackD>((double*) G__int(libp->para[0]), (double*) G__int(libp->para[1]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__TrackMathCoreDictLN_VecTracklETrackDgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__TrackMathCoreDict_245_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         string* pobj;
         string xobj = VecTrack<TrackD>::Type();
         pobj = new string(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__TrackMathCoreDict_245_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) VecTrack<TrackD>::IsD32());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__TrackMathCoreDict_245_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const VecTrack<TrackD>& obj = ((VecTrack<TrackD>*) G__getstructoffset())->operator+=(*(VecTrack<TrackD>*) libp->para[0].ref);
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__TrackMathCoreDict_245_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const VecTrack<TrackD>::It* pobj;
         const VecTrack<TrackD>::It xobj = ((const VecTrack<TrackD>*) G__getstructoffset())->begin();
         pobj = new VecTrack<TrackD>::It(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__TrackMathCoreDict_245_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const VecTrack<TrackD>::It* pobj;
         const VecTrack<TrackD>::It xobj = ((const VecTrack<TrackD>*) G__getstructoffset())->end();
         pobj = new VecTrack<TrackD>::It(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__TrackMathCoreDict_245_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const VecTrack<TrackD>*) G__getstructoffset())->Sum());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__TrackMathCoreDict_245_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((const VecTrack<TrackD>*) G__getstructoffset())->Print();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__TrackMathCoreDict_245_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   VecTrack<TrackD>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new VecTrack<TrackD>(*(VecTrack<TrackD>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__TrackMathCoreDictLN_VecTracklETrackDgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef VecTrack<TrackD> G__TVecTracklETrackDgR;
static int G__TrackMathCoreDict_245_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (VecTrack<TrackD>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((VecTrack<TrackD>*) (soff+(sizeof(VecTrack<TrackD>)*i)))->~G__TVecTracklETrackDgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (VecTrack<TrackD>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((VecTrack<TrackD>*) (soff))->~G__TVecTracklETrackDgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__TrackMathCoreDict_245_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   VecTrack<TrackD>* dest = (VecTrack<TrackD>*) G__getstructoffset();
   *dest = *(VecTrack<TrackD>*) libp->para[0].ref;
   const VecTrack<TrackD>& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* vector<TrackD,allocator<TrackD> > */
static int G__TrackMathCoreDict_247_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const TrackD& obj = ((vector<TrackD,allocator<TrackD> >*) G__getstructoffset())->at((vector<TrackD,allocator<TrackD> >::size_type) G__int(libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__TrackMathCoreDict_247_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<TrackD,allocator<TrackD> >::iterator* pobj;
         vector<TrackD,allocator<TrackD> >::iterator xobj = ((vector<TrackD,allocator<TrackD> >*) G__getstructoffset())->begin();
         pobj = new vector<TrackD,allocator<TrackD> >::iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__TrackMathCoreDict_247_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<TrackD,allocator<TrackD> >::iterator* pobj;
         vector<TrackD,allocator<TrackD> >::iterator xobj = ((vector<TrackD,allocator<TrackD> >*) G__getstructoffset())->end();
         pobj = new vector<TrackD,allocator<TrackD> >::iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__TrackMathCoreDict_247_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<TrackD,allocator<TrackD> >::reverse_iterator* pobj;
         vector<TrackD,allocator<TrackD> >::reverse_iterator xobj = ((vector<TrackD,allocator<TrackD> >*) G__getstructoffset())->rbegin();
         pobj = new vector<TrackD,allocator<TrackD> >::reverse_iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__TrackMathCoreDict_247_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<TrackD,allocator<TrackD> >::reverse_iterator* pobj;
         vector<TrackD,allocator<TrackD> >::reverse_iterator xobj = ((vector<TrackD,allocator<TrackD> >*) G__getstructoffset())->rend();
         pobj = new vector<TrackD,allocator<TrackD> >::reverse_iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__TrackMathCoreDict_247_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 107, (long) ((const vector<TrackD,allocator<TrackD> >*) G__getstructoffset())->size());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__TrackMathCoreDict_247_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 107, (long) ((const vector<TrackD,allocator<TrackD> >*) G__getstructoffset())->max_size());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__TrackMathCoreDict_247_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<TrackD,allocator<TrackD> >*) G__getstructoffset())->resize((vector<TrackD,allocator<TrackD> >::size_type) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__TrackMathCoreDict_247_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<TrackD,allocator<TrackD> >*) G__getstructoffset())->resize((vector<TrackD,allocator<TrackD> >::size_type) G__int(libp->para[0]), *((TrackD*) G__int(libp->para[1])));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__TrackMathCoreDict_247_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 107, (long) ((const vector<TrackD,allocator<TrackD> >*) G__getstructoffset())->capacity());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__TrackMathCoreDict_247_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const vector<TrackD,allocator<TrackD> >*) G__getstructoffset())->empty());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__TrackMathCoreDict_247_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const TrackD& obj = ((vector<TrackD,allocator<TrackD> >*) G__getstructoffset())->operator[]((vector<TrackD,allocator<TrackD> >::size_type) G__int(libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__TrackMathCoreDict_247_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   vector<TrackD,allocator<TrackD> >* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new vector<TrackD,allocator<TrackD> >[n];
     } else {
       p = new((void*) gvp) vector<TrackD,allocator<TrackD> >[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new vector<TrackD,allocator<TrackD> >;
     } else {
       p = new((void*) gvp) vector<TrackD,allocator<TrackD> >;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__TrackMathCoreDictLN_vectorlETrackDcOallocatorlETrackDgRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__TrackMathCoreDict_247_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   vector<TrackD,allocator<TrackD> >* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 2:
     //m: 2
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new vector<TrackD,allocator<TrackD> >((vector<TrackD,allocator<TrackD> >::size_type) G__int(libp->para[0]), *(TrackD*) libp->para[1].ref);
     } else {
       p = new((void*) gvp) vector<TrackD,allocator<TrackD> >((vector<TrackD,allocator<TrackD> >::size_type) G__int(libp->para[0]), *(TrackD*) libp->para[1].ref);
     }
     break;
   case 1:
     //m: 1
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new vector<TrackD,allocator<TrackD> >((vector<TrackD,allocator<TrackD> >::size_type) G__int(libp->para[0]));
     } else {
       p = new((void*) gvp) vector<TrackD,allocator<TrackD> >((vector<TrackD,allocator<TrackD> >::size_type) G__int(libp->para[0]));
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__TrackMathCoreDictLN_vectorlETrackDcOallocatorlETrackDgRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__TrackMathCoreDict_247_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   vector<TrackD,allocator<TrackD> >* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new vector<TrackD,allocator<TrackD> >(*(vector<TrackD,allocator<TrackD> >*) libp->para[0].ref);
   } else {
     p = new((void*) gvp) vector<TrackD,allocator<TrackD> >(*(vector<TrackD,allocator<TrackD> >*) libp->para[0].ref);
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__TrackMathCoreDictLN_vectorlETrackDcOallocatorlETrackDgRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__TrackMathCoreDict_247_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   vector<TrackD,allocator<TrackD> >* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new vector<TrackD,allocator<TrackD> >(*((vector<TrackD,allocator<TrackD> >::const_iterator*) G__int(libp->para[0])), *((vector<TrackD,allocator<TrackD> >::const_iterator*) G__int(libp->para[1])));
   } else {
     p = new((void*) gvp) vector<TrackD,allocator<TrackD> >(*((vector<TrackD,allocator<TrackD> >::const_iterator*) G__int(libp->para[0])), *((vector<TrackD,allocator<TrackD> >::const_iterator*) G__int(libp->para[1])));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__TrackMathCoreDictLN_vectorlETrackDcOallocatorlETrackDgRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__TrackMathCoreDict_247_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const vector<TrackD,allocator<TrackD> >& obj = ((vector<TrackD,allocator<TrackD> >*) G__getstructoffset())->operator=(*(vector<TrackD,allocator<TrackD> >*) libp->para[0].ref);
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__TrackMathCoreDict_247_0_18(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<TrackD,allocator<TrackD> >*) G__getstructoffset())->reserve((vector<TrackD,allocator<TrackD> >::size_type) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__TrackMathCoreDict_247_0_19(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const TrackD& obj = ((vector<TrackD,allocator<TrackD> >*) G__getstructoffset())->front();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__TrackMathCoreDict_247_0_20(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const TrackD& obj = ((vector<TrackD,allocator<TrackD> >*) G__getstructoffset())->back();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__TrackMathCoreDict_247_0_21(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<TrackD,allocator<TrackD> >*) G__getstructoffset())->push_back(*(TrackD*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__TrackMathCoreDict_247_0_22(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<TrackD,allocator<TrackD> >*) G__getstructoffset())->swap(*(vector<TrackD,allocator<TrackD> >*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__TrackMathCoreDict_247_0_23(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<TrackD,allocator<TrackD> >::iterator* pobj;
         vector<TrackD,allocator<TrackD> >::iterator xobj = ((vector<TrackD,allocator<TrackD> >*) G__getstructoffset())->insert(*((vector<TrackD,allocator<TrackD> >::iterator*) G__int(libp->para[0])), *(TrackD*) libp->para[1].ref);
         pobj = new vector<TrackD,allocator<TrackD> >::iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__TrackMathCoreDict_247_0_24(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<TrackD,allocator<TrackD> >*) G__getstructoffset())->insert(*((vector<TrackD,allocator<TrackD> >::iterator*) G__int(libp->para[0])), *((vector<TrackD,allocator<TrackD> >::const_iterator*) G__int(libp->para[1]))
, *((vector<TrackD,allocator<TrackD> >::const_iterator*) G__int(libp->para[2])));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__TrackMathCoreDict_247_0_25(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<TrackD,allocator<TrackD> >*) G__getstructoffset())->insert(*((vector<TrackD,allocator<TrackD> >::iterator*) G__int(libp->para[0])), (vector<TrackD,allocator<TrackD> >::size_type) G__int(libp->para[1])
, *(TrackD*) libp->para[2].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__TrackMathCoreDict_247_0_26(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<TrackD,allocator<TrackD> >*) G__getstructoffset())->pop_back();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__TrackMathCoreDict_247_0_27(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<TrackD,allocator<TrackD> >*) G__getstructoffset())->erase(*((vector<TrackD,allocator<TrackD> >::iterator*) G__int(libp->para[0])));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__TrackMathCoreDict_247_0_28(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<TrackD,allocator<TrackD> >*) G__getstructoffset())->erase(*((vector<TrackD,allocator<TrackD> >::iterator*) G__int(libp->para[0])), *((vector<TrackD,allocator<TrackD> >::iterator*) G__int(libp->para[1])));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__TrackMathCoreDict_247_0_29(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<TrackD,allocator<TrackD> >*) G__getstructoffset())->clear();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef vector<TrackD,allocator<TrackD> > G__TvectorlETrackDcOallocatorlETrackDgRsPgR;
static int G__TrackMathCoreDict_247_0_30(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (vector<TrackD,allocator<TrackD> >*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((vector<TrackD,allocator<TrackD> >*) (soff+(sizeof(vector<TrackD,allocator<TrackD> >)*i)))->~G__TvectorlETrackDcOallocatorlETrackDgRsPgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (vector<TrackD,allocator<TrackD> >*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((vector<TrackD,allocator<TrackD> >*) (soff))->~G__TvectorlETrackDcOallocatorlETrackDgRsPgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* VecTrack<TrackErrD> */
static int G__TrackMathCoreDict_251_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   VecTrack<TrackErrD>* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new VecTrack<TrackErrD>[n];
     } else {
       p = new((void*) gvp) VecTrack<TrackErrD>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new VecTrack<TrackErrD>;
     } else {
       p = new((void*) gvp) VecTrack<TrackErrD>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__TrackMathCoreDictLN_VecTracklETrackErrDgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__TrackMathCoreDict_251_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   VecTrack<TrackErrD>* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new VecTrack<TrackErrD>((double*) G__int(libp->para[0]), (double*) G__int(libp->para[1]));
   } else {
     p = new((void*) gvp) VecTrack<TrackErrD>((double*) G__int(libp->para[0]), (double*) G__int(libp->para[1]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__TrackMathCoreDictLN_VecTracklETrackErrDgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__TrackMathCoreDict_251_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         string* pobj;
         string xobj = VecTrack<TrackErrD>::Type();
         pobj = new string(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__TrackMathCoreDict_251_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) VecTrack<TrackErrD>::IsD32());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__TrackMathCoreDict_251_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const VecTrack<TrackErrD>& obj = ((VecTrack<TrackErrD>*) G__getstructoffset())->operator+=(*(VecTrack<TrackErrD>*) libp->para[0].ref);
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__TrackMathCoreDict_251_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const VecTrack<TrackErrD>::It* pobj;
         const VecTrack<TrackErrD>::It xobj = ((const VecTrack<TrackErrD>*) G__getstructoffset())->begin();
         pobj = new VecTrack<TrackErrD>::It(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__TrackMathCoreDict_251_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const VecTrack<TrackErrD>::It* pobj;
         const VecTrack<TrackErrD>::It xobj = ((const VecTrack<TrackErrD>*) G__getstructoffset())->end();
         pobj = new VecTrack<TrackErrD>::It(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__TrackMathCoreDict_251_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 100, (double) ((const VecTrack<TrackErrD>*) G__getstructoffset())->Sum());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__TrackMathCoreDict_251_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((const VecTrack<TrackErrD>*) G__getstructoffset())->Print();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__TrackMathCoreDict_251_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   VecTrack<TrackErrD>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new VecTrack<TrackErrD>(*(VecTrack<TrackErrD>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__TrackMathCoreDictLN_VecTracklETrackErrDgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef VecTrack<TrackErrD> G__TVecTracklETrackErrDgR;
static int G__TrackMathCoreDict_251_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (VecTrack<TrackErrD>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((VecTrack<TrackErrD>*) (soff+(sizeof(VecTrack<TrackErrD>)*i)))->~G__TVecTracklETrackErrDgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (VecTrack<TrackErrD>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((VecTrack<TrackErrD>*) (soff))->~G__TVecTracklETrackErrDgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__TrackMathCoreDict_251_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   VecTrack<TrackErrD>* dest = (VecTrack<TrackErrD>*) G__getstructoffset();
   *dest = *(VecTrack<TrackErrD>*) libp->para[0].ref;
   const VecTrack<TrackErrD>& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* vector<TrackErrD,allocator<TrackErrD> > */
static int G__TrackMathCoreDict_253_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const TrackErrD& obj = ((vector<TrackErrD,allocator<TrackErrD> >*) G__getstructoffset())->at((vector<TrackErrD,allocator<TrackErrD> >::size_type) G__int(libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__TrackMathCoreDict_253_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<TrackErrD,allocator<TrackErrD> >::iterator* pobj;
         vector<TrackErrD,allocator<TrackErrD> >::iterator xobj = ((vector<TrackErrD,allocator<TrackErrD> >*) G__getstructoffset())->begin();
         pobj = new vector<TrackErrD,allocator<TrackErrD> >::iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__TrackMathCoreDict_253_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<TrackErrD,allocator<TrackErrD> >::iterator* pobj;
         vector<TrackErrD,allocator<TrackErrD> >::iterator xobj = ((vector<TrackErrD,allocator<TrackErrD> >*) G__getstructoffset())->end();
         pobj = new vector<TrackErrD,allocator<TrackErrD> >::iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__TrackMathCoreDict_253_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<TrackErrD,allocator<TrackErrD> >::reverse_iterator* pobj;
         vector<TrackErrD,allocator<TrackErrD> >::reverse_iterator xobj = ((vector<TrackErrD,allocator<TrackErrD> >*) G__getstructoffset())->rbegin();
         pobj = new vector<TrackErrD,allocator<TrackErrD> >::reverse_iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__TrackMathCoreDict_253_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<TrackErrD,allocator<TrackErrD> >::reverse_iterator* pobj;
         vector<TrackErrD,allocator<TrackErrD> >::reverse_iterator xobj = ((vector<TrackErrD,allocator<TrackErrD> >*) G__getstructoffset())->rend();
         pobj = new vector<TrackErrD,allocator<TrackErrD> >::reverse_iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__TrackMathCoreDict_253_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 107, (long) ((const vector<TrackErrD,allocator<TrackErrD> >*) G__getstructoffset())->size());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__TrackMathCoreDict_253_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 107, (long) ((const vector<TrackErrD,allocator<TrackErrD> >*) G__getstructoffset())->max_size());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__TrackMathCoreDict_253_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<TrackErrD,allocator<TrackErrD> >*) G__getstructoffset())->resize((vector<TrackErrD,allocator<TrackErrD> >::size_type) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__TrackMathCoreDict_253_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<TrackErrD,allocator<TrackErrD> >*) G__getstructoffset())->resize((vector<TrackErrD,allocator<TrackErrD> >::size_type) G__int(libp->para[0]), *((TrackErrD*) G__int(libp->para[1])));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__TrackMathCoreDict_253_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 107, (long) ((const vector<TrackErrD,allocator<TrackErrD> >*) G__getstructoffset())->capacity());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__TrackMathCoreDict_253_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const vector<TrackErrD,allocator<TrackErrD> >*) G__getstructoffset())->empty());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__TrackMathCoreDict_253_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const TrackErrD& obj = ((vector<TrackErrD,allocator<TrackErrD> >*) G__getstructoffset())->operator[]((vector<TrackErrD,allocator<TrackErrD> >::size_type) G__int(libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__TrackMathCoreDict_253_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   vector<TrackErrD,allocator<TrackErrD> >* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new vector<TrackErrD,allocator<TrackErrD> >[n];
     } else {
       p = new((void*) gvp) vector<TrackErrD,allocator<TrackErrD> >[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new vector<TrackErrD,allocator<TrackErrD> >;
     } else {
       p = new((void*) gvp) vector<TrackErrD,allocator<TrackErrD> >;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__TrackMathCoreDictLN_vectorlETrackErrDcOallocatorlETrackErrDgRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__TrackMathCoreDict_253_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   vector<TrackErrD,allocator<TrackErrD> >* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 2:
     //m: 2
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new vector<TrackErrD,allocator<TrackErrD> >((vector<TrackErrD,allocator<TrackErrD> >::size_type) G__int(libp->para[0]), *(TrackErrD*) libp->para[1].ref);
     } else {
       p = new((void*) gvp) vector<TrackErrD,allocator<TrackErrD> >((vector<TrackErrD,allocator<TrackErrD> >::size_type) G__int(libp->para[0]), *(TrackErrD*) libp->para[1].ref);
     }
     break;
   case 1:
     //m: 1
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new vector<TrackErrD,allocator<TrackErrD> >((vector<TrackErrD,allocator<TrackErrD> >::size_type) G__int(libp->para[0]));
     } else {
       p = new((void*) gvp) vector<TrackErrD,allocator<TrackErrD> >((vector<TrackErrD,allocator<TrackErrD> >::size_type) G__int(libp->para[0]));
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__TrackMathCoreDictLN_vectorlETrackErrDcOallocatorlETrackErrDgRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__TrackMathCoreDict_253_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   vector<TrackErrD,allocator<TrackErrD> >* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new vector<TrackErrD,allocator<TrackErrD> >(*(vector<TrackErrD,allocator<TrackErrD> >*) libp->para[0].ref);
   } else {
     p = new((void*) gvp) vector<TrackErrD,allocator<TrackErrD> >(*(vector<TrackErrD,allocator<TrackErrD> >*) libp->para[0].ref);
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__TrackMathCoreDictLN_vectorlETrackErrDcOallocatorlETrackErrDgRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__TrackMathCoreDict_253_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   vector<TrackErrD,allocator<TrackErrD> >* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new vector<TrackErrD,allocator<TrackErrD> >(*((vector<TrackErrD,allocator<TrackErrD> >::const_iterator*) G__int(libp->para[0])), *((vector<TrackErrD,allocator<TrackErrD> >::const_iterator*) G__int(libp->para[1])));
   } else {
     p = new((void*) gvp) vector<TrackErrD,allocator<TrackErrD> >(*((vector<TrackErrD,allocator<TrackErrD> >::const_iterator*) G__int(libp->para[0])), *((vector<TrackErrD,allocator<TrackErrD> >::const_iterator*) G__int(libp->para[1])));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__TrackMathCoreDictLN_vectorlETrackErrDcOallocatorlETrackErrDgRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__TrackMathCoreDict_253_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const vector<TrackErrD,allocator<TrackErrD> >& obj = ((vector<TrackErrD,allocator<TrackErrD> >*) G__getstructoffset())->operator=(*(vector<TrackErrD,allocator<TrackErrD> >*) libp->para[0].ref);
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__TrackMathCoreDict_253_0_18(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<TrackErrD,allocator<TrackErrD> >*) G__getstructoffset())->reserve((vector<TrackErrD,allocator<TrackErrD> >::size_type) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__TrackMathCoreDict_253_0_19(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const TrackErrD& obj = ((vector<TrackErrD,allocator<TrackErrD> >*) G__getstructoffset())->front();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__TrackMathCoreDict_253_0_20(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const TrackErrD& obj = ((vector<TrackErrD,allocator<TrackErrD> >*) G__getstructoffset())->back();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__TrackMathCoreDict_253_0_21(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<TrackErrD,allocator<TrackErrD> >*) G__getstructoffset())->push_back(*(TrackErrD*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__TrackMathCoreDict_253_0_22(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<TrackErrD,allocator<TrackErrD> >*) G__getstructoffset())->swap(*(vector<TrackErrD,allocator<TrackErrD> >*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__TrackMathCoreDict_253_0_23(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<TrackErrD,allocator<TrackErrD> >::iterator* pobj;
         vector<TrackErrD,allocator<TrackErrD> >::iterator xobj = ((vector<TrackErrD,allocator<TrackErrD> >*) G__getstructoffset())->insert(*((vector<TrackErrD,allocator<TrackErrD> >::iterator*) G__int(libp->para[0])), *(TrackErrD*) libp->para[1].ref);
         pobj = new vector<TrackErrD,allocator<TrackErrD> >::iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__TrackMathCoreDict_253_0_24(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<TrackErrD,allocator<TrackErrD> >*) G__getstructoffset())->insert(*((vector<TrackErrD,allocator<TrackErrD> >::iterator*) G__int(libp->para[0])), *((vector<TrackErrD,allocator<TrackErrD> >::const_iterator*) G__int(libp->para[1]))
, *((vector<TrackErrD,allocator<TrackErrD> >::const_iterator*) G__int(libp->para[2])));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__TrackMathCoreDict_253_0_25(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<TrackErrD,allocator<TrackErrD> >*) G__getstructoffset())->insert(*((vector<TrackErrD,allocator<TrackErrD> >::iterator*) G__int(libp->para[0])), (vector<TrackErrD,allocator<TrackErrD> >::size_type) G__int(libp->para[1])
, *(TrackErrD*) libp->para[2].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__TrackMathCoreDict_253_0_26(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<TrackErrD,allocator<TrackErrD> >*) G__getstructoffset())->pop_back();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__TrackMathCoreDict_253_0_27(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<TrackErrD,allocator<TrackErrD> >*) G__getstructoffset())->erase(*((vector<TrackErrD,allocator<TrackErrD> >::iterator*) G__int(libp->para[0])));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__TrackMathCoreDict_253_0_28(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<TrackErrD,allocator<TrackErrD> >*) G__getstructoffset())->erase(*((vector<TrackErrD,allocator<TrackErrD> >::iterator*) G__int(libp->para[0])), *((vector<TrackErrD,allocator<TrackErrD> >::iterator*) G__int(libp->para[1])));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__TrackMathCoreDict_253_0_29(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<TrackErrD,allocator<TrackErrD> >*) G__getstructoffset())->clear();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef vector<TrackErrD,allocator<TrackErrD> > G__TvectorlETrackErrDcOallocatorlETrackErrDgRsPgR;
static int G__TrackMathCoreDict_253_0_30(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (vector<TrackErrD,allocator<TrackErrD> >*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((vector<TrackErrD,allocator<TrackErrD> >*) (soff+(sizeof(vector<TrackErrD,allocator<TrackErrD> >)*i)))->~G__TvectorlETrackErrDcOallocatorlETrackErrDgRsPgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (vector<TrackErrD,allocator<TrackErrD> >*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((vector<TrackErrD,allocator<TrackErrD> >*) (soff))->~G__TvectorlETrackErrDcOallocatorlETrackErrDgRsPgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* Setting up global function */

/*********************************************************
* Member function Stub
*********************************************************/

/* TrackD */

/* TrackD32 */

/* TrackErrD */

/* TrackErrD32 */

/* VecTrack<TrackD> */

/* vector<TrackD,allocator<TrackD> > */

/* VecTrack<TrackErrD> */

/* vector<TrackErrD,allocator<TrackErrD> > */

/*********************************************************
* Global function Stub
*********************************************************/

/*********************************************************
* Get size of pointer to member function
*********************************************************/
class G__Sizep2memfuncTrackMathCoreDict {
 public:
  G__Sizep2memfuncTrackMathCoreDict(): p(&G__Sizep2memfuncTrackMathCoreDict::sizep2memfunc) {}
    size_t sizep2memfunc() { return(sizeof(p)); }
  private:
    size_t (G__Sizep2memfuncTrackMathCoreDict::*p)();
};

size_t G__get_sizep2memfuncTrackMathCoreDict()
{
  G__Sizep2memfuncTrackMathCoreDict a;
  G__setsizep2memfunc((int)a.sizep2memfunc());
  return((size_t)a.sizep2memfunc());
}


/*********************************************************
* virtual base class offset calculation interface
*********************************************************/

   /* Setting up class inheritance */

/*********************************************************
* Inheritance information setup/
*********************************************************/
extern "C" void G__cpp_setup_inheritanceTrackMathCoreDict() {

   /* Setting up class inheritance */
}

/*********************************************************
* typedef information setup/
*********************************************************/
extern "C" void G__cpp_setup_typetableTrackMathCoreDict() {

   /* Setting up typedef entry */
   G__search_typename2("vector<TSchemaHelper>",117,G__get_linked_tagnum(&G__TrackMathCoreDictLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__TrackMathCoreDictLN_reverse_iteratorlEvectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__TrackMathCoreDictLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__TrackMathCoreDictLN_reverse_iteratorlEvectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__TrackMathCoreDictLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<ROOT::TSchemaHelper>",117,G__get_linked_tagnum(&G__TrackMathCoreDictLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("Vector4D",117,G__get_linked_tagnum(&G__TrackMathCoreDictLN_ROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("Vector4D32",117,G__get_linked_tagnum(&G__TrackMathCoreDictLN_ROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEDouble32_tgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double> >",117,G__get_linked_tagnum(&G__TrackMathCoreDictLN_ROOTcLcLMathcLcLDisplacementVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double> >",117,G__get_linked_tagnum(&G__TrackMathCoreDictLN_ROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("Point3D",117,G__get_linked_tagnum(&G__TrackMathCoreDictLN_ROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<Double32_t> >",117,G__get_linked_tagnum(&G__TrackMathCoreDictLN_ROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEDouble32_tgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("Point3D32",117,G__get_linked_tagnum(&G__TrackMathCoreDictLN_ROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEDouble32_tgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("SVector<double,4*(4+1)/2>",117,G__get_linked_tagnum(&G__TrackMathCoreDictLN_ROOTcLcLMathcLcLSVectorlEdoublecO10gR),0,G__get_linked_tagnum(&G__TrackMathCoreDictLN_ROOTcLcLMath));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("Matrix4D",117,G__get_linked_tagnum(&G__TrackMathCoreDictLN_ROOTcLcLMathcLcLSMatrixlEdoublecO4cO4cOROOTcLcLMathcLcLMatRepStdlEdoublecO4cO4gRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("SVector<Double32_t,4*(4+1)/2>",117,G__get_linked_tagnum(&G__TrackMathCoreDictLN_ROOTcLcLMathcLcLSVectorlEDouble32_tcO10gR),0,G__get_linked_tagnum(&G__TrackMathCoreDictLN_ROOTcLcLMath));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("Matrix4D32",117,G__get_linked_tagnum(&G__TrackMathCoreDictLN_ROOTcLcLMathcLcLSMatrixlEDouble32_tcO4cO4cOROOTcLcLMathcLcLMatRepStdlEDouble32_tcO4cO4gRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("SVector<double,6*(6+1)/2>",117,G__get_linked_tagnum(&G__TrackMathCoreDictLN_ROOTcLcLMathcLcLSVectorlEdoublecO21gR),0,G__get_linked_tagnum(&G__TrackMathCoreDictLN_ROOTcLcLMath));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("SymMatrix6D",117,G__get_linked_tagnum(&G__TrackMathCoreDictLN_ROOTcLcLMathcLcLSMatrixlEdoublecO6cO6cOROOTcLcLMathcLcLMatRepSymlEdoublecO6gRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("SVector<Double32_t,6*(6+1)/2>",117,G__get_linked_tagnum(&G__TrackMathCoreDictLN_ROOTcLcLMathcLcLSVectorlEDouble32_tcO21gR),0,G__get_linked_tagnum(&G__TrackMathCoreDictLN_ROOTcLcLMath));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("SymMatrix6D32",117,G__get_linked_tagnum(&G__TrackMathCoreDictLN_ROOTcLcLMathcLcLSMatrixlEDouble32_tcO6cO6cOROOTcLcLMathcLcLMatRepSymlEDouble32_tcO6gRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("const_iterator",68,-1,0,G__get_linked_tagnum(&G__TrackMathCoreDictLN_TrackD));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("const_iterator",68,-1,0,G__get_linked_tagnum(&G__TrackMathCoreDictLN_TrackD32));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("const_iterator",68,-1,0,G__get_linked_tagnum(&G__TrackMathCoreDictLN_TrackErrD));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("const_iterator",68,-1,0,G__get_linked_tagnum(&G__TrackMathCoreDictLN_TrackErrD32));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<TrackD>",117,G__get_linked_tagnum(&G__TrackMathCoreDictLN_vectorlETrackDcOallocatorlETrackDgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("value_type",117,G__get_linked_tagnum(&G__TrackMathCoreDictLN_TrackD),0,G__get_linked_tagnum(&G__TrackMathCoreDictLN_vectorlETrackDcOallocatorlETrackDgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("pointer",85,G__get_linked_tagnum(&G__TrackMathCoreDictLN_TrackD),0,G__get_linked_tagnum(&G__TrackMathCoreDictLN_vectorlETrackDcOallocatorlETrackDgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("const_pointer",85,G__get_linked_tagnum(&G__TrackMathCoreDictLN_TrackD),256,G__get_linked_tagnum(&G__TrackMathCoreDictLN_vectorlETrackDcOallocatorlETrackDgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reference",117,G__get_linked_tagnum(&G__TrackMathCoreDictLN_TrackD),1,G__get_linked_tagnum(&G__TrackMathCoreDictLN_vectorlETrackDcOallocatorlETrackDgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("const_reference",117,G__get_linked_tagnum(&G__TrackMathCoreDictLN_TrackD),257,G__get_linked_tagnum(&G__TrackMathCoreDictLN_vectorlETrackDcOallocatorlETrackDgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("size_type",107,-1,0,G__get_linked_tagnum(&G__TrackMathCoreDictLN_vectorlETrackDcOallocatorlETrackDgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("difference_type",108,-1,0,G__get_linked_tagnum(&G__TrackMathCoreDictLN_vectorlETrackDcOallocatorlETrackDgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("const_iterator",117,G__get_linked_tagnum(&G__TrackMathCoreDictLN_vectorlETrackDcOallocatorlETrackDgRsPgRcLcLiterator),256,G__get_linked_tagnum(&G__TrackMathCoreDictLN_vectorlETrackDcOallocatorlETrackDgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__TrackMathCoreDictLN_reverse_iteratorlEvectorlETrackDcOallocatorlETrackDgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__TrackMathCoreDictLN_vectorlETrackDcOallocatorlETrackDgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("const_reverse_iterator",117,G__get_linked_tagnum(&G__TrackMathCoreDictLN_reverse_iteratorlEvectorlETrackDcOallocatorlETrackDgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__TrackMathCoreDictLN_vectorlETrackDcOallocatorlETrackDgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__TrackMathCoreDictLN_reverse_iteratorlEvectorlETrackDcOallocatorlETrackDgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__TrackMathCoreDictLN_vectorlETrackDcOallocatorlETrackDgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator",117,G__get_linked_tagnum(&G__TrackMathCoreDictLN_reverse_iteratorlEvectorlETrackDcOallocatorlETrackDgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__TrackMathCoreDictLN_vectorlETrackDcOallocatorlETrackDgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("It",117,G__get_linked_tagnum(&G__TrackMathCoreDictLN_vectorlETrackDcOallocatorlETrackDgRsPgRcLcLiterator),0,G__get_linked_tagnum(&G__TrackMathCoreDictLN_VecTracklETrackDgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<TrackErrD>",117,G__get_linked_tagnum(&G__TrackMathCoreDictLN_vectorlETrackErrDcOallocatorlETrackErrDgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("value_type",117,G__get_linked_tagnum(&G__TrackMathCoreDictLN_TrackErrD),0,G__get_linked_tagnum(&G__TrackMathCoreDictLN_vectorlETrackErrDcOallocatorlETrackErrDgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("pointer",85,G__get_linked_tagnum(&G__TrackMathCoreDictLN_TrackErrD),0,G__get_linked_tagnum(&G__TrackMathCoreDictLN_vectorlETrackErrDcOallocatorlETrackErrDgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("const_pointer",85,G__get_linked_tagnum(&G__TrackMathCoreDictLN_TrackErrD),256,G__get_linked_tagnum(&G__TrackMathCoreDictLN_vectorlETrackErrDcOallocatorlETrackErrDgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reference",117,G__get_linked_tagnum(&G__TrackMathCoreDictLN_TrackErrD),1,G__get_linked_tagnum(&G__TrackMathCoreDictLN_vectorlETrackErrDcOallocatorlETrackErrDgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("const_reference",117,G__get_linked_tagnum(&G__TrackMathCoreDictLN_TrackErrD),257,G__get_linked_tagnum(&G__TrackMathCoreDictLN_vectorlETrackErrDcOallocatorlETrackErrDgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("size_type",107,-1,0,G__get_linked_tagnum(&G__TrackMathCoreDictLN_vectorlETrackErrDcOallocatorlETrackErrDgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("difference_type",108,-1,0,G__get_linked_tagnum(&G__TrackMathCoreDictLN_vectorlETrackErrDcOallocatorlETrackErrDgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("const_iterator",117,G__get_linked_tagnum(&G__TrackMathCoreDictLN_vectorlETrackErrDcOallocatorlETrackErrDgRsPgRcLcLiterator),256,G__get_linked_tagnum(&G__TrackMathCoreDictLN_vectorlETrackErrDcOallocatorlETrackErrDgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__TrackMathCoreDictLN_reverse_iteratorlEvectorlETrackErrDcOallocatorlETrackErrDgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__TrackMathCoreDictLN_vectorlETrackErrDcOallocatorlETrackErrDgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("const_reverse_iterator",117,G__get_linked_tagnum(&G__TrackMathCoreDictLN_reverse_iteratorlEvectorlETrackErrDcOallocatorlETrackErrDgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__TrackMathCoreDictLN_vectorlETrackErrDcOallocatorlETrackErrDgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__TrackMathCoreDictLN_reverse_iteratorlEvectorlETrackErrDcOallocatorlETrackErrDgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__TrackMathCoreDictLN_vectorlETrackErrDcOallocatorlETrackErrDgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator",117,G__get_linked_tagnum(&G__TrackMathCoreDictLN_reverse_iteratorlEvectorlETrackErrDcOallocatorlETrackErrDgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__TrackMathCoreDictLN_vectorlETrackErrDcOallocatorlETrackErrDgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("It",117,G__get_linked_tagnum(&G__TrackMathCoreDictLN_vectorlETrackErrDcOallocatorlETrackErrDgRsPgRcLcLiterator),0,G__get_linked_tagnum(&G__TrackMathCoreDictLN_VecTracklETrackErrDgR));
   G__setnewtype(-1,NULL,0);
}

/*********************************************************
* Data Member information setup/
*********************************************************/

   /* Setting up class,struct,union tag member variable */

   /* TrackD */
static void G__setup_memvarTrackD(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__TrackMathCoreDictLN_TrackD));
   { TrackD *p; p=(TrackD*)0x1000; if (p) { }
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__TrackMathCoreDictLN_TrackDcLcLdA),-1,-2,1,"kSize=7",0,(char*)NULL);
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__TrackMathCoreDictLN_ROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggR),G__defined_typename("Point3D"),-1,4,"fPos=",0,(char*)NULL);
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__TrackMathCoreDictLN_ROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgR),G__defined_typename("Vector4D"),-1,4,"fVec=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* TrackD32 */
static void G__setup_memvarTrackD32(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__TrackMathCoreDictLN_TrackD32));
   { TrackD32 *p; p=(TrackD32*)0x1000; if (p) { }
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__TrackMathCoreDictLN_TrackD32cLcLdA),-1,-2,1,"kSize=7",0,(char*)NULL);
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__TrackMathCoreDictLN_ROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEDouble32_tgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggR),G__defined_typename("Point3D32"),-1,4,"fPos=",0,(char*)NULL);
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__TrackMathCoreDictLN_ROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEDouble32_tgRsPgR),G__defined_typename("Vector4D32"),-1,4,"fVec=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* TrackErrD */
static void G__setup_memvarTrackErrD(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__TrackMathCoreDictLN_TrackErrD));
   { TrackErrD *p; p=(TrackErrD*)0x1000; if (p) { }
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__TrackMathCoreDictLN_TrackErrDcLcLdA),-1,-2,1,"kSize=44",0,(char*)NULL);
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__TrackMathCoreDictLN_ROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggR),G__defined_typename("Point3D"),-1,4,"fPos=",0,(char*)NULL);
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__TrackMathCoreDictLN_ROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgR),G__defined_typename("Vector4D"),-1,4,"fVec=",0,(char*)NULL);
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__TrackMathCoreDictLN_ROOTcLcLMathcLcLSMatrixlEdoublecO4cO4cOROOTcLcLMathcLcLMatRepStdlEdoublecO4cO4gRsPgR),G__defined_typename("Matrix4D"),-1,4,"fMat=",0,(char*)NULL);
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__TrackMathCoreDictLN_ROOTcLcLMathcLcLSMatrixlEdoublecO6cO6cOROOTcLcLMathcLcLMatRepSymlEdoublecO6gRsPgR),G__defined_typename("SymMatrix6D"),-1,4,"fSymMat=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* TrackErrD32 */
static void G__setup_memvarTrackErrD32(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__TrackMathCoreDictLN_TrackErrD32));
   { TrackErrD32 *p; p=(TrackErrD32*)0x1000; if (p) { }
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__TrackMathCoreDictLN_TrackErrD32cLcLdA),-1,-2,1,"kSize=44",0,(char*)NULL);
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__TrackMathCoreDictLN_ROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEDouble32_tgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggR),G__defined_typename("Point3D32"),-1,4,"fPos=",0,(char*)NULL);
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__TrackMathCoreDictLN_ROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEDouble32_tgRsPgR),G__defined_typename("Vector4D32"),-1,4,"fVec=",0,(char*)NULL);
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__TrackMathCoreDictLN_ROOTcLcLMathcLcLSMatrixlEDouble32_tcO4cO4cOROOTcLcLMathcLcLMatRepStdlEDouble32_tcO4cO4gRsPgR),G__defined_typename("Matrix4D32"),-1,4,"fMat=",0,(char*)NULL);
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__TrackMathCoreDictLN_ROOTcLcLMathcLcLSMatrixlEDouble32_tcO6cO6cOROOTcLcLMathcLcLMatRepSymlEDouble32_tcO6gRsPgR),G__defined_typename("SymMatrix6D32"),-1,4,"fSymMat=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* VecTrack<TrackD> */
static void G__setup_memvarVecTracklETrackDgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__TrackMathCoreDictLN_VecTracklETrackDgR));
   { VecTrack<TrackD> *p; p=(VecTrack<TrackD>*)0x1000; if (p) { }
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__TrackMathCoreDictLN_VecTracklETrackDgRcLcLdA),-1,-2,1,"kLen=3",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__TrackMathCoreDictLN_VecTracklETrackDgRcLcLdA),-1,-2,1,"kSize=21",0,(char*)NULL);
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__TrackMathCoreDictLN_vectorlETrackDcOallocatorlETrackDgRsPgR),G__defined_typename("vector<TrackD>"),-1,4,"fTrks=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* vector<TrackD,allocator<TrackD> > */
static void G__setup_memvarvectorlETrackDcOallocatorlETrackDgRsPgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__TrackMathCoreDictLN_vectorlETrackDcOallocatorlETrackDgRsPgR));
   { vector<TrackD,allocator<TrackD> > *p; p=(vector<TrackD,allocator<TrackD> >*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* VecTrack<TrackErrD> */
static void G__setup_memvarVecTracklETrackErrDgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__TrackMathCoreDictLN_VecTracklETrackErrDgR));
   { VecTrack<TrackErrD> *p; p=(VecTrack<TrackErrD>*)0x1000; if (p) { }
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__TrackMathCoreDictLN_VecTracklETrackErrDgRcLcLdA),-1,-2,1,"kLen=3",0,(char*)NULL);
   G__memvar_setup((void*)G__PVOID,105,0,1,G__get_linked_tagnum(&G__TrackMathCoreDictLN_VecTracklETrackErrDgRcLcLdA),-1,-2,1,"kSize=132",0,(char*)NULL);
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__TrackMathCoreDictLN_vectorlETrackErrDcOallocatorlETrackErrDgRsPgR),G__defined_typename("vector<TrackErrD>"),-1,4,"fTrks=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* vector<TrackErrD,allocator<TrackErrD> > */
static void G__setup_memvarvectorlETrackErrDcOallocatorlETrackErrDgRsPgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__TrackMathCoreDictLN_vectorlETrackErrDcOallocatorlETrackErrDgRsPgR));
   { vector<TrackErrD,allocator<TrackErrD> > *p; p=(vector<TrackErrD,allocator<TrackErrD> >*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}

extern "C" void G__cpp_setup_memvarTrackMathCoreDict() {
}
/***********************************************************
************************************************************
************************************************************
************************************************************
************************************************************
************************************************************
************************************************************
***********************************************************/

/*********************************************************
* Member function information setup for each class
*********************************************************/
static void G__setup_memfuncTrackD(void) {
   /* TrackD */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__TrackMathCoreDictLN_TrackD));
   G__memfunc_setup("TrackD",569,G__TrackMathCoreDict_236_0_1, 105, G__get_linked_tagnum(&G__TrackMathCoreDictLN_TrackD), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("TrackD",569,G__TrackMathCoreDict_236_0_2, 105, G__get_linked_tagnum(&G__TrackMathCoreDictLN_TrackD), -1, 0, 2, 1, 1, 0, 
"D - - 0 - begin D - - 0 - end", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Type",418,G__TrackMathCoreDict_236_0_3, 117, G__get_linked_tagnum(&G__TrackMathCoreDictLN_string), -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (string (*)())(&TrackD::Type) ), 0);
   G__memfunc_setup("IsD32",357,G__TrackMathCoreDict_236_0_4, 103, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (bool (*)())(&TrackD::IsD32) ), 0);
   G__memfunc_setup("operator+=",980,G__TrackMathCoreDict_236_0_5, 117, G__get_linked_tagnum(&G__TrackMathCoreDictLN_TrackD), -1, 1, 1, 1, 1, 0, "u 'TrackD' - 11 - t", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Sum",309,G__TrackMathCoreDict_236_0_6, 100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Print",525,G__TrackMathCoreDict_236_0_7, 121, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("TrackD", 569, G__TrackMathCoreDict_236_0_8, (int) ('i'), G__get_linked_tagnum(&G__TrackMathCoreDictLN_TrackD), -1, 0, 1, 1, 1, 0, "u 'TrackD' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~TrackD", 695, G__TrackMathCoreDict_236_0_9, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__TrackMathCoreDict_236_0_10, (int) ('u'), G__get_linked_tagnum(&G__TrackMathCoreDictLN_TrackD), -1, 1, 1, 1, 1, 0, "u 'TrackD' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncTrackD32(void) {
   /* TrackD32 */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__TrackMathCoreDictLN_TrackD32));
   G__memfunc_setup("TrackD32",670,G__TrackMathCoreDict_238_0_1, 105, G__get_linked_tagnum(&G__TrackMathCoreDictLN_TrackD32), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Type",418,G__TrackMathCoreDict_238_0_2, 117, G__get_linked_tagnum(&G__TrackMathCoreDictLN_string), -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (string (*)())(&TrackD32::Type) ), 0);
   G__memfunc_setup("IsD32",357,G__TrackMathCoreDict_238_0_3, 103, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (bool (*)())(&TrackD32::IsD32) ), 0);
   G__memfunc_setup("TrackD32",670,G__TrackMathCoreDict_238_0_4, 105, G__get_linked_tagnum(&G__TrackMathCoreDictLN_TrackD32), -1, 0, 2, 1, 1, 0, 
"D - - 0 - begin D - - 0 - end", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator+=",980,G__TrackMathCoreDict_238_0_5, 117, G__get_linked_tagnum(&G__TrackMathCoreDictLN_TrackD32), -1, 1, 1, 1, 1, 0, "u 'TrackD32' - 11 - t", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Sum",309,G__TrackMathCoreDict_238_0_6, 100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Print",525,G__TrackMathCoreDict_238_0_7, 121, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("TrackD32", 670, G__TrackMathCoreDict_238_0_8, (int) ('i'), G__get_linked_tagnum(&G__TrackMathCoreDictLN_TrackD32), -1, 0, 1, 1, 1, 0, "u 'TrackD32' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~TrackD32", 796, G__TrackMathCoreDict_238_0_9, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__TrackMathCoreDict_238_0_10, (int) ('u'), G__get_linked_tagnum(&G__TrackMathCoreDictLN_TrackD32), -1, 1, 1, 1, 1, 0, "u 'TrackD32' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncTrackErrD(void) {
   /* TrackErrD */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__TrackMathCoreDictLN_TrackErrD));
   G__memfunc_setup("TrackErrD",866,G__TrackMathCoreDict_240_0_1, 105, G__get_linked_tagnum(&G__TrackMathCoreDictLN_TrackErrD), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("TrackErrD",866,G__TrackMathCoreDict_240_0_2, 105, G__get_linked_tagnum(&G__TrackMathCoreDictLN_TrackErrD), -1, 0, 2, 1, 1, 0, 
"D - - 0 - begin D - - 0 - end", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Type",418,G__TrackMathCoreDict_240_0_3, 117, G__get_linked_tagnum(&G__TrackMathCoreDictLN_string), -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (string (*)())(&TrackErrD::Type) ), 0);
   G__memfunc_setup("IsD32",357,G__TrackMathCoreDict_240_0_4, 103, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (bool (*)())(&TrackErrD::IsD32) ), 0);
   G__memfunc_setup("operator+=",980,G__TrackMathCoreDict_240_0_5, 117, G__get_linked_tagnum(&G__TrackMathCoreDictLN_TrackErrD), -1, 1, 1, 1, 1, 0, "u 'TrackErrD' - 11 - t", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Sum",309,G__TrackMathCoreDict_240_0_6, 100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Print",525,G__TrackMathCoreDict_240_0_7, 121, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("TrackErrD", 866, G__TrackMathCoreDict_240_0_8, (int) ('i'), G__get_linked_tagnum(&G__TrackMathCoreDictLN_TrackErrD), -1, 0, 1, 1, 1, 0, "u 'TrackErrD' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~TrackErrD", 992, G__TrackMathCoreDict_240_0_9, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__TrackMathCoreDict_240_0_10, (int) ('u'), G__get_linked_tagnum(&G__TrackMathCoreDictLN_TrackErrD), -1, 1, 1, 1, 1, 0, "u 'TrackErrD' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncTrackErrD32(void) {
   /* TrackErrD32 */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__TrackMathCoreDictLN_TrackErrD32));
   G__memfunc_setup("TrackErrD32",967,G__TrackMathCoreDict_242_0_1, 105, G__get_linked_tagnum(&G__TrackMathCoreDictLN_TrackErrD32), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Type",418,G__TrackMathCoreDict_242_0_2, 117, G__get_linked_tagnum(&G__TrackMathCoreDictLN_string), -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (string (*)())(&TrackErrD32::Type) ), 0);
   G__memfunc_setup("IsD32",357,G__TrackMathCoreDict_242_0_3, 103, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (bool (*)())(&TrackErrD32::IsD32) ), 0);
   G__memfunc_setup("TrackErrD32",967,G__TrackMathCoreDict_242_0_4, 105, G__get_linked_tagnum(&G__TrackMathCoreDictLN_TrackErrD32), -1, 0, 2, 1, 1, 0, 
"D - - 0 - begin D - - 0 - end", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator+=",980,G__TrackMathCoreDict_242_0_5, 117, G__get_linked_tagnum(&G__TrackMathCoreDictLN_TrackErrD32), -1, 1, 1, 1, 1, 0, "u 'TrackErrD32' - 11 - t", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Sum",309,G__TrackMathCoreDict_242_0_6, 100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Print",525,G__TrackMathCoreDict_242_0_7, 121, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("TrackErrD32", 967, G__TrackMathCoreDict_242_0_8, (int) ('i'), G__get_linked_tagnum(&G__TrackMathCoreDictLN_TrackErrD32), -1, 0, 1, 1, 1, 0, "u 'TrackErrD32' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~TrackErrD32", 1093, G__TrackMathCoreDict_242_0_9, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__TrackMathCoreDict_242_0_10, (int) ('u'), G__get_linked_tagnum(&G__TrackMathCoreDictLN_TrackErrD32), -1, 1, 1, 1, 1, 0, "u 'TrackErrD32' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncVecTracklETrackDgR(void) {
   /* VecTrack<TrackD> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__TrackMathCoreDictLN_VecTracklETrackDgR));
   G__memfunc_setup("VecTrack<TrackD>",1478,G__TrackMathCoreDict_245_0_1, 105, G__get_linked_tagnum(&G__TrackMathCoreDictLN_VecTracklETrackDgR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("VecTrack<TrackD>",1478,G__TrackMathCoreDict_245_0_2, 105, G__get_linked_tagnum(&G__TrackMathCoreDictLN_VecTracklETrackDgR), -1, 0, 2, 1, 1, 0, 
"D - - 0 - ibegin D - - 0 - iend", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Type",418,G__TrackMathCoreDict_245_0_3, 117, G__get_linked_tagnum(&G__TrackMathCoreDictLN_string), -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (string (*)())(&VecTrack<TrackD>::Type) ), 0);
   G__memfunc_setup("IsD32",357,G__TrackMathCoreDict_245_0_4, 103, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (bool (*)())(&VecTrack<TrackD>::IsD32) ), 0);
   G__memfunc_setup("operator+=",980,G__TrackMathCoreDict_245_0_5, 117, G__get_linked_tagnum(&G__TrackMathCoreDictLN_VecTracklETrackDgR), -1, 1, 1, 1, 1, 0, "u 'VecTrack<TrackD>' - 11 - v", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("begin",517,G__TrackMathCoreDict_245_0_6, 117, G__get_linked_tagnum(&G__TrackMathCoreDictLN_vectorlETrackDcOallocatorlETrackDgRsPgRcLcLiterator), G__defined_typename("VecTrack<TrackD>::It"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("end",311,G__TrackMathCoreDict_245_0_7, 117, G__get_linked_tagnum(&G__TrackMathCoreDictLN_vectorlETrackDcOallocatorlETrackDgRsPgRcLcLiterator), G__defined_typename("VecTrack<TrackD>::It"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Sum",309,G__TrackMathCoreDict_245_0_8, 100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Print",525,G__TrackMathCoreDict_245_0_9, 121, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("VecTrack<TrackD>", 1478, G__TrackMathCoreDict_245_0_10, (int) ('i'), G__get_linked_tagnum(&G__TrackMathCoreDictLN_VecTracklETrackDgR), -1, 0, 1, 1, 1, 0, "u 'VecTrack<TrackD>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~VecTrack<TrackD>", 1604, G__TrackMathCoreDict_245_0_11, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__TrackMathCoreDict_245_0_12, (int) ('u'), G__get_linked_tagnum(&G__TrackMathCoreDictLN_VecTracklETrackDgR), -1, 1, 1, 1, 1, 0, "u 'VecTrack<TrackD>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncvectorlETrackDcOallocatorlETrackDgRsPgR(void) {
   /* vector<TrackD,allocator<TrackD> > */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__TrackMathCoreDictLN_vectorlETrackDcOallocatorlETrackDgRsPgR));
   G__memfunc_setup("at",213,G__TrackMathCoreDict_247_0_1, 117, G__get_linked_tagnum(&G__TrackMathCoreDictLN_TrackD), -1, 1, 1, 1, 1, 0, "k - 'vector<TrackD,allocator<TrackD> >::size_type' 0 - n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("begin",517,G__TrackMathCoreDict_247_0_2, 117, G__get_linked_tagnum(&G__TrackMathCoreDictLN_vectorlETrackDcOallocatorlETrackDgRsPgRcLcLiterator), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("end",311,G__TrackMathCoreDict_247_0_3, 117, G__get_linked_tagnum(&G__TrackMathCoreDictLN_vectorlETrackDcOallocatorlETrackDgRsPgRcLcLiterator), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("rbegin",631,G__TrackMathCoreDict_247_0_4, 117, G__get_linked_tagnum(&G__TrackMathCoreDictLN_reverse_iteratorlEvectorlETrackDcOallocatorlETrackDgRsPgRcLcLiteratorgR), G__defined_typename("vector<TrackD,allocator<TrackD> >::reverse_iterator"), 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("rend",425,G__TrackMathCoreDict_247_0_5, 117, G__get_linked_tagnum(&G__TrackMathCoreDictLN_reverse_iteratorlEvectorlETrackDcOallocatorlETrackDgRsPgRcLcLiteratorgR), G__defined_typename("vector<TrackD,allocator<TrackD> >::reverse_iterator"), 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("size",443,G__TrackMathCoreDict_247_0_6, 107, -1, G__defined_typename("vector<TrackD,allocator<TrackD> >::size_type"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("max_size",864,G__TrackMathCoreDict_247_0_7, 107, -1, G__defined_typename("vector<TrackD,allocator<TrackD> >::size_type"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("resize",658,G__TrackMathCoreDict_247_0_8, 121, -1, -1, 0, 1, 1, 1, 0, "k - 'vector<TrackD,allocator<TrackD> >::size_type' 0 - sz", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("resize",658,G__TrackMathCoreDict_247_0_9, 121, -1, -1, 0, 2, 1, 1, 0, 
"k - 'vector<TrackD,allocator<TrackD> >::size_type' 0 - sz u 'TrackD' - 0 - c", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("capacity",846,G__TrackMathCoreDict_247_0_10, 107, -1, G__defined_typename("vector<TrackD,allocator<TrackD> >::size_type"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("empty",559,G__TrackMathCoreDict_247_0_11, 103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator[]",1060,G__TrackMathCoreDict_247_0_12, 117, G__get_linked_tagnum(&G__TrackMathCoreDictLN_TrackD), -1, 1, 1, 1, 1, 0, "k - 'vector<TrackD,allocator<TrackD> >::size_type' 0 - n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("vector<TrackD,allocator<TrackD> >",3078,G__TrackMathCoreDict_247_0_13, 105, G__get_linked_tagnum(&G__TrackMathCoreDictLN_vectorlETrackDcOallocatorlETrackDgRsPgR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("vector<TrackD,allocator<TrackD> >",3078,G__TrackMathCoreDict_247_0_14, 105, G__get_linked_tagnum(&G__TrackMathCoreDictLN_vectorlETrackDcOallocatorlETrackDgRsPgR), -1, 0, 2, 1, 1, 0, 
"k - 'vector<TrackD,allocator<TrackD> >::size_type' 0 - n u 'TrackD' - 11 'TrackD()' value", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("vector<TrackD,allocator<TrackD> >",3078,G__TrackMathCoreDict_247_0_15, 105, G__get_linked_tagnum(&G__TrackMathCoreDictLN_vectorlETrackDcOallocatorlETrackDgRsPgR), -1, 0, 1, 1, 1, 0, "u 'vector<TrackD,allocator<TrackD> >' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("vector<TrackD,allocator<TrackD> >",3078,G__TrackMathCoreDict_247_0_16, 105, G__get_linked_tagnum(&G__TrackMathCoreDictLN_vectorlETrackDcOallocatorlETrackDgRsPgR), -1, 0, 2, 1, 1, 0, 
"u 'vector<TrackD,allocator<TrackD> >::iterator' 'vector<TrackD,allocator<TrackD> >::const_iterator' 10 - first u 'vector<TrackD,allocator<TrackD> >::iterator' 'vector<TrackD,allocator<TrackD> >::const_iterator' 10 - last", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,G__TrackMathCoreDict_247_0_17, 117, G__get_linked_tagnum(&G__TrackMathCoreDictLN_vectorlETrackDcOallocatorlETrackDgRsPgR), -1, 1, 1, 1, 1, 0, "u 'vector<TrackD,allocator<TrackD> >' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("reserve",764,G__TrackMathCoreDict_247_0_18, 121, -1, -1, 0, 1, 1, 1, 0, "k - 'vector<TrackD,allocator<TrackD> >::size_type' 0 - n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("front",553,G__TrackMathCoreDict_247_0_19, 117, G__get_linked_tagnum(&G__TrackMathCoreDictLN_TrackD), -1, 1, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("back",401,G__TrackMathCoreDict_247_0_20, 117, G__get_linked_tagnum(&G__TrackMathCoreDictLN_TrackD), -1, 1, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("push_back",944,G__TrackMathCoreDict_247_0_21, 121, -1, -1, 0, 1, 1, 1, 0, "u 'TrackD' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("swap",443,G__TrackMathCoreDict_247_0_22, 121, -1, -1, 0, 1, 1, 1, 0, "u 'vector<TrackD,allocator<TrackD> >' - 1 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("insert",661,G__TrackMathCoreDict_247_0_23, 117, G__get_linked_tagnum(&G__TrackMathCoreDictLN_vectorlETrackDcOallocatorlETrackDgRsPgRcLcLiterator), -1, 0, 2, 1, 1, 0, 
"u 'vector<TrackD,allocator<TrackD> >::iterator' - 0 - position u 'TrackD' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("insert",661,G__TrackMathCoreDict_247_0_24, 121, -1, -1, 0, 3, 1, 1, 0, 
"u 'vector<TrackD,allocator<TrackD> >::iterator' - 0 - position u 'vector<TrackD,allocator<TrackD> >::iterator' 'vector<TrackD,allocator<TrackD> >::const_iterator' 10 - first "
"u 'vector<TrackD,allocator<TrackD> >::iterator' 'vector<TrackD,allocator<TrackD> >::const_iterator' 10 - last", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("insert",661,G__TrackMathCoreDict_247_0_25, 121, -1, -1, 0, 3, 1, 1, 0, 
"u 'vector<TrackD,allocator<TrackD> >::iterator' - 0 - position k - 'vector<TrackD,allocator<TrackD> >::size_type' 0 - n "
"u 'TrackD' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("pop_back",831,G__TrackMathCoreDict_247_0_26, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("erase",528,G__TrackMathCoreDict_247_0_27, 121, -1, -1, 0, 1, 1, 1, 0, "u 'vector<TrackD,allocator<TrackD> >::iterator' - 0 - position", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("erase",528,G__TrackMathCoreDict_247_0_28, 121, -1, -1, 0, 2, 1, 1, 0, 
"u 'vector<TrackD,allocator<TrackD> >::iterator' - 0 - first u 'vector<TrackD,allocator<TrackD> >::iterator' - 0 - last", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("clear",519,G__TrackMathCoreDict_247_0_29, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~vector<TrackD,allocator<TrackD> >", 3204, G__TrackMathCoreDict_247_0_30, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncVecTracklETrackErrDgR(void) {
   /* VecTrack<TrackErrD> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__TrackMathCoreDictLN_VecTracklETrackErrDgR));
   G__memfunc_setup("VecTrack<TrackErrD>",1775,G__TrackMathCoreDict_251_0_1, 105, G__get_linked_tagnum(&G__TrackMathCoreDictLN_VecTracklETrackErrDgR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("VecTrack<TrackErrD>",1775,G__TrackMathCoreDict_251_0_2, 105, G__get_linked_tagnum(&G__TrackMathCoreDictLN_VecTracklETrackErrDgR), -1, 0, 2, 1, 1, 0, 
"D - - 0 - ibegin D - - 0 - iend", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Type",418,G__TrackMathCoreDict_251_0_3, 117, G__get_linked_tagnum(&G__TrackMathCoreDictLN_string), -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (string (*)())(&VecTrack<TrackErrD>::Type) ), 0);
   G__memfunc_setup("IsD32",357,G__TrackMathCoreDict_251_0_4, 103, -1, -1, 0, 0, 3, 1, 0, "", (char*)NULL, (void*) G__func2void( (bool (*)())(&VecTrack<TrackErrD>::IsD32) ), 0);
   G__memfunc_setup("operator+=",980,G__TrackMathCoreDict_251_0_5, 117, G__get_linked_tagnum(&G__TrackMathCoreDictLN_VecTracklETrackErrDgR), -1, 1, 1, 1, 1, 0, "u 'VecTrack<TrackErrD>' - 11 - v", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("begin",517,G__TrackMathCoreDict_251_0_6, 117, G__get_linked_tagnum(&G__TrackMathCoreDictLN_vectorlETrackErrDcOallocatorlETrackErrDgRsPgRcLcLiterator), G__defined_typename("VecTrack<TrackErrD>::It"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("end",311,G__TrackMathCoreDict_251_0_7, 117, G__get_linked_tagnum(&G__TrackMathCoreDictLN_vectorlETrackErrDcOallocatorlETrackErrDgRsPgRcLcLiterator), G__defined_typename("VecTrack<TrackErrD>::It"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Sum",309,G__TrackMathCoreDict_251_0_8, 100, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Print",525,G__TrackMathCoreDict_251_0_9, 121, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("VecTrack<TrackErrD>", 1775, G__TrackMathCoreDict_251_0_10, (int) ('i'), G__get_linked_tagnum(&G__TrackMathCoreDictLN_VecTracklETrackErrDgR), -1, 0, 1, 1, 1, 0, "u 'VecTrack<TrackErrD>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~VecTrack<TrackErrD>", 1901, G__TrackMathCoreDict_251_0_11, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__TrackMathCoreDict_251_0_12, (int) ('u'), G__get_linked_tagnum(&G__TrackMathCoreDictLN_VecTracklETrackErrDgR), -1, 1, 1, 1, 1, 0, "u 'VecTrack<TrackErrD>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncvectorlETrackErrDcOallocatorlETrackErrDgRsPgR(void) {
   /* vector<TrackErrD,allocator<TrackErrD> > */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__TrackMathCoreDictLN_vectorlETrackErrDcOallocatorlETrackErrDgRsPgR));
   G__memfunc_setup("at",213,G__TrackMathCoreDict_253_0_1, 117, G__get_linked_tagnum(&G__TrackMathCoreDictLN_TrackErrD), -1, 1, 1, 1, 1, 0, "k - 'vector<TrackErrD,allocator<TrackErrD> >::size_type' 0 - n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("begin",517,G__TrackMathCoreDict_253_0_2, 117, G__get_linked_tagnum(&G__TrackMathCoreDictLN_vectorlETrackErrDcOallocatorlETrackErrDgRsPgRcLcLiterator), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("end",311,G__TrackMathCoreDict_253_0_3, 117, G__get_linked_tagnum(&G__TrackMathCoreDictLN_vectorlETrackErrDcOallocatorlETrackErrDgRsPgRcLcLiterator), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("rbegin",631,G__TrackMathCoreDict_253_0_4, 117, G__get_linked_tagnum(&G__TrackMathCoreDictLN_reverse_iteratorlEvectorlETrackErrDcOallocatorlETrackErrDgRsPgRcLcLiteratorgR), G__defined_typename("vector<TrackErrD,allocator<TrackErrD> >::reverse_iterator"), 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("rend",425,G__TrackMathCoreDict_253_0_5, 117, G__get_linked_tagnum(&G__TrackMathCoreDictLN_reverse_iteratorlEvectorlETrackErrDcOallocatorlETrackErrDgRsPgRcLcLiteratorgR), G__defined_typename("vector<TrackErrD,allocator<TrackErrD> >::reverse_iterator"), 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("size",443,G__TrackMathCoreDict_253_0_6, 107, -1, G__defined_typename("vector<TrackErrD,allocator<TrackErrD> >::size_type"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("max_size",864,G__TrackMathCoreDict_253_0_7, 107, -1, G__defined_typename("vector<TrackErrD,allocator<TrackErrD> >::size_type"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("resize",658,G__TrackMathCoreDict_253_0_8, 121, -1, -1, 0, 1, 1, 1, 0, "k - 'vector<TrackErrD,allocator<TrackErrD> >::size_type' 0 - sz", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("resize",658,G__TrackMathCoreDict_253_0_9, 121, -1, -1, 0, 2, 1, 1, 0, 
"k - 'vector<TrackErrD,allocator<TrackErrD> >::size_type' 0 - sz u 'TrackErrD' - 0 - c", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("capacity",846,G__TrackMathCoreDict_253_0_10, 107, -1, G__defined_typename("vector<TrackErrD,allocator<TrackErrD> >::size_type"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("empty",559,G__TrackMathCoreDict_253_0_11, 103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator[]",1060,G__TrackMathCoreDict_253_0_12, 117, G__get_linked_tagnum(&G__TrackMathCoreDictLN_TrackErrD), -1, 1, 1, 1, 1, 0, "k - 'vector<TrackErrD,allocator<TrackErrD> >::size_type' 0 - n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("vector<TrackErrD,allocator<TrackErrD> >",3672,G__TrackMathCoreDict_253_0_13, 105, G__get_linked_tagnum(&G__TrackMathCoreDictLN_vectorlETrackErrDcOallocatorlETrackErrDgRsPgR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("vector<TrackErrD,allocator<TrackErrD> >",3672,G__TrackMathCoreDict_253_0_14, 105, G__get_linked_tagnum(&G__TrackMathCoreDictLN_vectorlETrackErrDcOallocatorlETrackErrDgRsPgR), -1, 0, 2, 1, 1, 0, 
"k - 'vector<TrackErrD,allocator<TrackErrD> >::size_type' 0 - n u 'TrackErrD' - 11 'TrackErrD()' value", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("vector<TrackErrD,allocator<TrackErrD> >",3672,G__TrackMathCoreDict_253_0_15, 105, G__get_linked_tagnum(&G__TrackMathCoreDictLN_vectorlETrackErrDcOallocatorlETrackErrDgRsPgR), -1, 0, 1, 1, 1, 0, "u 'vector<TrackErrD,allocator<TrackErrD> >' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("vector<TrackErrD,allocator<TrackErrD> >",3672,G__TrackMathCoreDict_253_0_16, 105, G__get_linked_tagnum(&G__TrackMathCoreDictLN_vectorlETrackErrDcOallocatorlETrackErrDgRsPgR), -1, 0, 2, 1, 1, 0, 
"u 'vector<TrackErrD,allocator<TrackErrD> >::iterator' 'vector<TrackErrD,allocator<TrackErrD> >::const_iterator' 10 - first u 'vector<TrackErrD,allocator<TrackErrD> >::iterator' 'vector<TrackErrD,allocator<TrackErrD> >::const_iterator' 10 - last", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,G__TrackMathCoreDict_253_0_17, 117, G__get_linked_tagnum(&G__TrackMathCoreDictLN_vectorlETrackErrDcOallocatorlETrackErrDgRsPgR), -1, 1, 1, 1, 1, 0, "u 'vector<TrackErrD,allocator<TrackErrD> >' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("reserve",764,G__TrackMathCoreDict_253_0_18, 121, -1, -1, 0, 1, 1, 1, 0, "k - 'vector<TrackErrD,allocator<TrackErrD> >::size_type' 0 - n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("front",553,G__TrackMathCoreDict_253_0_19, 117, G__get_linked_tagnum(&G__TrackMathCoreDictLN_TrackErrD), -1, 1, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("back",401,G__TrackMathCoreDict_253_0_20, 117, G__get_linked_tagnum(&G__TrackMathCoreDictLN_TrackErrD), -1, 1, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("push_back",944,G__TrackMathCoreDict_253_0_21, 121, -1, -1, 0, 1, 1, 1, 0, "u 'TrackErrD' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("swap",443,G__TrackMathCoreDict_253_0_22, 121, -1, -1, 0, 1, 1, 1, 0, "u 'vector<TrackErrD,allocator<TrackErrD> >' - 1 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("insert",661,G__TrackMathCoreDict_253_0_23, 117, G__get_linked_tagnum(&G__TrackMathCoreDictLN_vectorlETrackErrDcOallocatorlETrackErrDgRsPgRcLcLiterator), -1, 0, 2, 1, 1, 0, 
"u 'vector<TrackErrD,allocator<TrackErrD> >::iterator' - 0 - position u 'TrackErrD' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("insert",661,G__TrackMathCoreDict_253_0_24, 121, -1, -1, 0, 3, 1, 1, 0, 
"u 'vector<TrackErrD,allocator<TrackErrD> >::iterator' - 0 - position u 'vector<TrackErrD,allocator<TrackErrD> >::iterator' 'vector<TrackErrD,allocator<TrackErrD> >::const_iterator' 10 - first "
"u 'vector<TrackErrD,allocator<TrackErrD> >::iterator' 'vector<TrackErrD,allocator<TrackErrD> >::const_iterator' 10 - last", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("insert",661,G__TrackMathCoreDict_253_0_25, 121, -1, -1, 0, 3, 1, 1, 0, 
"u 'vector<TrackErrD,allocator<TrackErrD> >::iterator' - 0 - position k - 'vector<TrackErrD,allocator<TrackErrD> >::size_type' 0 - n "
"u 'TrackErrD' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("pop_back",831,G__TrackMathCoreDict_253_0_26, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("erase",528,G__TrackMathCoreDict_253_0_27, 121, -1, -1, 0, 1, 1, 1, 0, "u 'vector<TrackErrD,allocator<TrackErrD> >::iterator' - 0 - position", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("erase",528,G__TrackMathCoreDict_253_0_28, 121, -1, -1, 0, 2, 1, 1, 0, 
"u 'vector<TrackErrD,allocator<TrackErrD> >::iterator' - 0 - first u 'vector<TrackErrD,allocator<TrackErrD> >::iterator' - 0 - last", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("clear",519,G__TrackMathCoreDict_253_0_29, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~vector<TrackErrD,allocator<TrackErrD> >", 3798, G__TrackMathCoreDict_253_0_30, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}


/*********************************************************
* Member function information setup
*********************************************************/
extern "C" void G__cpp_setup_memfuncTrackMathCoreDict() {
}

/*********************************************************
* Global variable information setup for each class
*********************************************************/
static void G__cpp_setup_global0() {

   /* Setting up global variables */
   G__resetplocal();

}

static void G__cpp_setup_global1() {

   G__resetglobalenv();
}
extern "C" void G__cpp_setup_globalTrackMathCoreDict() {
  G__cpp_setup_global0();
  G__cpp_setup_global1();
}

/*********************************************************
* Global function information setup for each class
*********************************************************/
static void G__cpp_setup_func0() {
   G__lastifuncposition();

}

static void G__cpp_setup_func1() {
}

static void G__cpp_setup_func2() {
}

static void G__cpp_setup_func3() {
}

static void G__cpp_setup_func4() {
}

static void G__cpp_setup_func5() {
}

static void G__cpp_setup_func6() {
}

static void G__cpp_setup_func7() {
}

static void G__cpp_setup_func8() {
}

static void G__cpp_setup_func9() {
}

static void G__cpp_setup_func10() {
}

static void G__cpp_setup_func11() {
}

static void G__cpp_setup_func12() {

   G__resetifuncposition();
}

extern "C" void G__cpp_setup_funcTrackMathCoreDict() {
  G__cpp_setup_func0();
  G__cpp_setup_func1();
  G__cpp_setup_func2();
  G__cpp_setup_func3();
  G__cpp_setup_func4();
  G__cpp_setup_func5();
  G__cpp_setup_func6();
  G__cpp_setup_func7();
  G__cpp_setup_func8();
  G__cpp_setup_func9();
  G__cpp_setup_func10();
  G__cpp_setup_func11();
  G__cpp_setup_func12();
}

/*********************************************************
* Class,struct,union,enum tag information setup
*********************************************************/
/* Setup class/struct taginfo */
G__linked_taginfo G__TrackMathCoreDictLN_ROOT = { "ROOT" , 110 , -1 };
G__linked_taginfo G__TrackMathCoreDictLN_string = { "string" , 99 , -1 };
G__linked_taginfo G__TrackMathCoreDictLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR = { "vector<ROOT::TSchemaHelper,allocator<ROOT::TSchemaHelper> >" , 99 , -1 };
G__linked_taginfo G__TrackMathCoreDictLN_reverse_iteratorlEvectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgRcLcLiteratorgR = { "reverse_iterator<vector<ROOT::TSchemaHelper,allocator<ROOT::TSchemaHelper> >::iterator>" , 99 , -1 };
G__linked_taginfo G__TrackMathCoreDictLN_ROOTcLcLMath = { "ROOT::Math" , 110 , -1 };
G__linked_taginfo G__TrackMathCoreDictLN_ROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggR = { "ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>" , 99 , -1 };
G__linked_taginfo G__TrackMathCoreDictLN_ROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgR = { "ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >" , 99 , -1 };
G__linked_taginfo G__TrackMathCoreDictLN_ROOTcLcLMathcLcLDisplacementVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggR = { "ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>" , 99 , -1 };
G__linked_taginfo G__TrackMathCoreDictLN_ROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEDouble32_tgRsPgR = { "ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<Double32_t> >" , 99 , -1 };
G__linked_taginfo G__TrackMathCoreDictLN_ROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEDouble32_tgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggR = { "ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>" , 99 , -1 };
G__linked_taginfo G__TrackMathCoreDictLN_ROOTcLcLMathcLcLSMatrixlEdoublecO4cO4cOROOTcLcLMathcLcLMatRepStdlEdoublecO4cO4gRsPgR = { "ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >" , 99 , -1 };
G__linked_taginfo G__TrackMathCoreDictLN_ROOTcLcLMathcLcLSVectorlEdoublecO10gR = { "ROOT::Math::SVector<double,10>" , 99 , -1 };
G__linked_taginfo G__TrackMathCoreDictLN_ROOTcLcLMathcLcLSMatrixlEDouble32_tcO4cO4cOROOTcLcLMathcLcLMatRepStdlEDouble32_tcO4cO4gRsPgR = { "ROOT::Math::SMatrix<Double32_t,4,4,ROOT::Math::MatRepStd<Double32_t,4,4> >" , 99 , -1 };
G__linked_taginfo G__TrackMathCoreDictLN_ROOTcLcLMathcLcLSVectorlEDouble32_tcO10gR = { "ROOT::Math::SVector<Double32_t,10>" , 99 , -1 };
G__linked_taginfo G__TrackMathCoreDictLN_ROOTcLcLMathcLcLSMatrixlEdoublecO6cO6cOROOTcLcLMathcLcLMatRepSymlEdoublecO6gRsPgR = { "ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >" , 99 , -1 };
G__linked_taginfo G__TrackMathCoreDictLN_ROOTcLcLMathcLcLSVectorlEdoublecO21gR = { "ROOT::Math::SVector<double,21>" , 99 , -1 };
G__linked_taginfo G__TrackMathCoreDictLN_ROOTcLcLMathcLcLSMatrixlEDouble32_tcO6cO6cOROOTcLcLMathcLcLMatRepSymlEDouble32_tcO6gRsPgR = { "ROOT::Math::SMatrix<Double32_t,6,6,ROOT::Math::MatRepSym<Double32_t,6> >" , 99 , -1 };
G__linked_taginfo G__TrackMathCoreDictLN_ROOTcLcLMathcLcLSVectorlEDouble32_tcO21gR = { "ROOT::Math::SVector<Double32_t,21>" , 99 , -1 };
G__linked_taginfo G__TrackMathCoreDictLN_TrackD = { "TrackD" , 99 , -1 };
G__linked_taginfo G__TrackMathCoreDictLN_TrackDcLcLdA = { "TrackD::$" , 101 , -1 };
G__linked_taginfo G__TrackMathCoreDictLN_TrackD32 = { "TrackD32" , 99 , -1 };
G__linked_taginfo G__TrackMathCoreDictLN_TrackD32cLcLdA = { "TrackD32::$" , 101 , -1 };
G__linked_taginfo G__TrackMathCoreDictLN_TrackErrD = { "TrackErrD" , 99 , -1 };
G__linked_taginfo G__TrackMathCoreDictLN_TrackErrDcLcLdA = { "TrackErrD::$" , 101 , -1 };
G__linked_taginfo G__TrackMathCoreDictLN_TrackErrD32 = { "TrackErrD32" , 99 , -1 };
G__linked_taginfo G__TrackMathCoreDictLN_TrackErrD32cLcLdA = { "TrackErrD32::$" , 101 , -1 };
G__linked_taginfo G__TrackMathCoreDictLN_VecTracklETrackDgR = { "VecTrack<TrackD>" , 99 , -1 };
G__linked_taginfo G__TrackMathCoreDictLN_vectorlETrackDcOallocatorlETrackDgRsPgR = { "vector<TrackD,allocator<TrackD> >" , 99 , -1 };
G__linked_taginfo G__TrackMathCoreDictLN_vectorlETrackDcOallocatorlETrackDgRsPgRcLcLiterator = { "vector<TrackD,allocator<TrackD> >::iterator" , 99 , -1 };
G__linked_taginfo G__TrackMathCoreDictLN_reverse_iteratorlEvectorlETrackDcOallocatorlETrackDgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<TrackD,allocator<TrackD> >::iterator>" , 99 , -1 };
G__linked_taginfo G__TrackMathCoreDictLN_VecTracklETrackDgRcLcLdA = { "VecTrack<TrackD>::$" , 101 , -1 };
G__linked_taginfo G__TrackMathCoreDictLN_VecTracklETrackErrDgR = { "VecTrack<TrackErrD>" , 99 , -1 };
G__linked_taginfo G__TrackMathCoreDictLN_vectorlETrackErrDcOallocatorlETrackErrDgRsPgR = { "vector<TrackErrD,allocator<TrackErrD> >" , 99 , -1 };
G__linked_taginfo G__TrackMathCoreDictLN_vectorlETrackErrDcOallocatorlETrackErrDgRsPgRcLcLiterator = { "vector<TrackErrD,allocator<TrackErrD> >::iterator" , 99 , -1 };
G__linked_taginfo G__TrackMathCoreDictLN_reverse_iteratorlEvectorlETrackErrDcOallocatorlETrackErrDgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<TrackErrD,allocator<TrackErrD> >::iterator>" , 99 , -1 };
G__linked_taginfo G__TrackMathCoreDictLN_VecTracklETrackErrDgRcLcLdA = { "VecTrack<TrackErrD>::$" , 101 , -1 };

/* Reset class/struct taginfo */
extern "C" void G__cpp_reset_tagtableTrackMathCoreDict() {
  G__TrackMathCoreDictLN_ROOT.tagnum = -1 ;
  G__TrackMathCoreDictLN_string.tagnum = -1 ;
  G__TrackMathCoreDictLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR.tagnum = -1 ;
  G__TrackMathCoreDictLN_reverse_iteratorlEvectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__TrackMathCoreDictLN_ROOTcLcLMath.tagnum = -1 ;
  G__TrackMathCoreDictLN_ROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggR.tagnum = -1 ;
  G__TrackMathCoreDictLN_ROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgR.tagnum = -1 ;
  G__TrackMathCoreDictLN_ROOTcLcLMathcLcLDisplacementVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggR.tagnum = -1 ;
  G__TrackMathCoreDictLN_ROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEDouble32_tgRsPgR.tagnum = -1 ;
  G__TrackMathCoreDictLN_ROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEDouble32_tgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggR.tagnum = -1 ;
  G__TrackMathCoreDictLN_ROOTcLcLMathcLcLSMatrixlEdoublecO4cO4cOROOTcLcLMathcLcLMatRepStdlEdoublecO4cO4gRsPgR.tagnum = -1 ;
  G__TrackMathCoreDictLN_ROOTcLcLMathcLcLSVectorlEdoublecO10gR.tagnum = -1 ;
  G__TrackMathCoreDictLN_ROOTcLcLMathcLcLSMatrixlEDouble32_tcO4cO4cOROOTcLcLMathcLcLMatRepStdlEDouble32_tcO4cO4gRsPgR.tagnum = -1 ;
  G__TrackMathCoreDictLN_ROOTcLcLMathcLcLSVectorlEDouble32_tcO10gR.tagnum = -1 ;
  G__TrackMathCoreDictLN_ROOTcLcLMathcLcLSMatrixlEdoublecO6cO6cOROOTcLcLMathcLcLMatRepSymlEdoublecO6gRsPgR.tagnum = -1 ;
  G__TrackMathCoreDictLN_ROOTcLcLMathcLcLSVectorlEdoublecO21gR.tagnum = -1 ;
  G__TrackMathCoreDictLN_ROOTcLcLMathcLcLSMatrixlEDouble32_tcO6cO6cOROOTcLcLMathcLcLMatRepSymlEDouble32_tcO6gRsPgR.tagnum = -1 ;
  G__TrackMathCoreDictLN_ROOTcLcLMathcLcLSVectorlEDouble32_tcO21gR.tagnum = -1 ;
  G__TrackMathCoreDictLN_TrackD.tagnum = -1 ;
  G__TrackMathCoreDictLN_TrackDcLcLdA.tagnum = -1 ;
  G__TrackMathCoreDictLN_TrackD32.tagnum = -1 ;
  G__TrackMathCoreDictLN_TrackD32cLcLdA.tagnum = -1 ;
  G__TrackMathCoreDictLN_TrackErrD.tagnum = -1 ;
  G__TrackMathCoreDictLN_TrackErrDcLcLdA.tagnum = -1 ;
  G__TrackMathCoreDictLN_TrackErrD32.tagnum = -1 ;
  G__TrackMathCoreDictLN_TrackErrD32cLcLdA.tagnum = -1 ;
  G__TrackMathCoreDictLN_VecTracklETrackDgR.tagnum = -1 ;
  G__TrackMathCoreDictLN_vectorlETrackDcOallocatorlETrackDgRsPgR.tagnum = -1 ;
  G__TrackMathCoreDictLN_vectorlETrackDcOallocatorlETrackDgRsPgRcLcLiterator.tagnum = -1 ;
  G__TrackMathCoreDictLN_reverse_iteratorlEvectorlETrackDcOallocatorlETrackDgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__TrackMathCoreDictLN_VecTracklETrackDgRcLcLdA.tagnum = -1 ;
  G__TrackMathCoreDictLN_VecTracklETrackErrDgR.tagnum = -1 ;
  G__TrackMathCoreDictLN_vectorlETrackErrDcOallocatorlETrackErrDgRsPgR.tagnum = -1 ;
  G__TrackMathCoreDictLN_vectorlETrackErrDcOallocatorlETrackErrDgRsPgRcLcLiterator.tagnum = -1 ;
  G__TrackMathCoreDictLN_reverse_iteratorlEvectorlETrackErrDcOallocatorlETrackErrDgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__TrackMathCoreDictLN_VecTracklETrackErrDgRcLcLdA.tagnum = -1 ;
}


extern "C" void G__cpp_setup_tagtableTrackMathCoreDict() {

   /* Setting up class,struct,union tag entry */
   G__get_linked_tagnum_fwd(&G__TrackMathCoreDictLN_ROOT);
   G__get_linked_tagnum_fwd(&G__TrackMathCoreDictLN_string);
   G__get_linked_tagnum_fwd(&G__TrackMathCoreDictLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR);
   G__get_linked_tagnum_fwd(&G__TrackMathCoreDictLN_reverse_iteratorlEvectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__TrackMathCoreDictLN_ROOTcLcLMath);
   G__get_linked_tagnum_fwd(&G__TrackMathCoreDictLN_ROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggR);
   G__get_linked_tagnum_fwd(&G__TrackMathCoreDictLN_ROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgR);
   G__get_linked_tagnum_fwd(&G__TrackMathCoreDictLN_ROOTcLcLMathcLcLDisplacementVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggR);
   G__get_linked_tagnum_fwd(&G__TrackMathCoreDictLN_ROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEDouble32_tgRsPgR);
   G__get_linked_tagnum_fwd(&G__TrackMathCoreDictLN_ROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEDouble32_tgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggR);
   G__get_linked_tagnum_fwd(&G__TrackMathCoreDictLN_ROOTcLcLMathcLcLSMatrixlEdoublecO4cO4cOROOTcLcLMathcLcLMatRepStdlEdoublecO4cO4gRsPgR);
   G__get_linked_tagnum_fwd(&G__TrackMathCoreDictLN_ROOTcLcLMathcLcLSVectorlEdoublecO10gR);
   G__get_linked_tagnum_fwd(&G__TrackMathCoreDictLN_ROOTcLcLMathcLcLSMatrixlEDouble32_tcO4cO4cOROOTcLcLMathcLcLMatRepStdlEDouble32_tcO4cO4gRsPgR);
   G__get_linked_tagnum_fwd(&G__TrackMathCoreDictLN_ROOTcLcLMathcLcLSVectorlEDouble32_tcO10gR);
   G__get_linked_tagnum_fwd(&G__TrackMathCoreDictLN_ROOTcLcLMathcLcLSMatrixlEdoublecO6cO6cOROOTcLcLMathcLcLMatRepSymlEdoublecO6gRsPgR);
   G__get_linked_tagnum_fwd(&G__TrackMathCoreDictLN_ROOTcLcLMathcLcLSVectorlEdoublecO21gR);
   G__get_linked_tagnum_fwd(&G__TrackMathCoreDictLN_ROOTcLcLMathcLcLSMatrixlEDouble32_tcO6cO6cOROOTcLcLMathcLcLMatRepSymlEDouble32_tcO6gRsPgR);
   G__get_linked_tagnum_fwd(&G__TrackMathCoreDictLN_ROOTcLcLMathcLcLSVectorlEDouble32_tcO21gR);
   G__tagtable_setup(G__get_linked_tagnum(&G__TrackMathCoreDictLN_TrackD),sizeof(TrackD),-1,295168,(char*)NULL,G__setup_memvarTrackD,G__setup_memfuncTrackD);
   G__get_linked_tagnum_fwd(&G__TrackMathCoreDictLN_TrackDcLcLdA);
   G__tagtable_setup(G__get_linked_tagnum(&G__TrackMathCoreDictLN_TrackD32),sizeof(TrackD32),-1,295168,(char*)NULL,G__setup_memvarTrackD32,G__setup_memfuncTrackD32);
   G__get_linked_tagnum_fwd(&G__TrackMathCoreDictLN_TrackD32cLcLdA);
   G__tagtable_setup(G__get_linked_tagnum(&G__TrackMathCoreDictLN_TrackErrD),sizeof(TrackErrD),-1,295168,(char*)NULL,G__setup_memvarTrackErrD,G__setup_memfuncTrackErrD);
   G__get_linked_tagnum_fwd(&G__TrackMathCoreDictLN_TrackErrDcLcLdA);
   G__tagtable_setup(G__get_linked_tagnum(&G__TrackMathCoreDictLN_TrackErrD32),sizeof(TrackErrD32),-1,295168,(char*)NULL,G__setup_memvarTrackErrD32,G__setup_memfuncTrackErrD32);
   G__get_linked_tagnum_fwd(&G__TrackMathCoreDictLN_TrackErrD32cLcLdA);
   G__tagtable_setup(G__get_linked_tagnum(&G__TrackMathCoreDictLN_VecTracklETrackDgR),sizeof(VecTrack<TrackD>),-1,295168,(char*)NULL,G__setup_memvarVecTracklETrackDgR,G__setup_memfuncVecTracklETrackDgR);
   G__tagtable_setup(G__get_linked_tagnum(&G__TrackMathCoreDictLN_vectorlETrackDcOallocatorlETrackDgRsPgR),sizeof(vector<TrackD,allocator<TrackD> >),-1,298752,(char*)NULL,G__setup_memvarvectorlETrackDcOallocatorlETrackDgRsPgR,G__setup_memfuncvectorlETrackDcOallocatorlETrackDgRsPgR);
   G__get_linked_tagnum_fwd(&G__TrackMathCoreDictLN_vectorlETrackDcOallocatorlETrackDgRsPgRcLcLiterator);
   G__get_linked_tagnum_fwd(&G__TrackMathCoreDictLN_reverse_iteratorlEvectorlETrackDcOallocatorlETrackDgRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__TrackMathCoreDictLN_VecTracklETrackDgRcLcLdA);
   G__tagtable_setup(G__get_linked_tagnum(&G__TrackMathCoreDictLN_VecTracklETrackErrDgR),sizeof(VecTrack<TrackErrD>),-1,295168,(char*)NULL,G__setup_memvarVecTracklETrackErrDgR,G__setup_memfuncVecTracklETrackErrDgR);
   G__tagtable_setup(G__get_linked_tagnum(&G__TrackMathCoreDictLN_vectorlETrackErrDcOallocatorlETrackErrDgRsPgR),sizeof(vector<TrackErrD,allocator<TrackErrD> >),-1,298752,(char*)NULL,G__setup_memvarvectorlETrackErrDcOallocatorlETrackErrDgRsPgR,G__setup_memfuncvectorlETrackErrDcOallocatorlETrackErrDgRsPgR);
   G__get_linked_tagnum_fwd(&G__TrackMathCoreDictLN_vectorlETrackErrDcOallocatorlETrackErrDgRsPgRcLcLiterator);
   G__get_linked_tagnum_fwd(&G__TrackMathCoreDictLN_reverse_iteratorlEvectorlETrackErrDcOallocatorlETrackErrDgRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__TrackMathCoreDictLN_VecTracklETrackErrDgRcLcLdA);
}
extern "C" void G__cpp_setupTrackMathCoreDict(void) {
  G__check_setup_version(30051515,"G__cpp_setupTrackMathCoreDict()");
  G__set_cpp_environmentTrackMathCoreDict();
  G__cpp_setup_tagtableTrackMathCoreDict();

  G__cpp_setup_inheritanceTrackMathCoreDict();

  G__cpp_setup_typetableTrackMathCoreDict();

  G__cpp_setup_memvarTrackMathCoreDict();

  G__cpp_setup_memfuncTrackMathCoreDict();
  G__cpp_setup_globalTrackMathCoreDict();
  G__cpp_setup_funcTrackMathCoreDict();

   if(0==G__getsizep2memfunc()) G__get_sizep2memfuncTrackMathCoreDict();
  return;
}
class G__cpp_setup_initTrackMathCoreDict {
  public:
    G__cpp_setup_initTrackMathCoreDict() { G__add_setup_func("TrackMathCoreDict",(G__incsetup)(&G__cpp_setupTrackMathCoreDict)); G__call_setup_funcs(); }
   ~G__cpp_setup_initTrackMathCoreDict() { G__remove_setup_func("TrackMathCoreDict"); }
};
G__cpp_setup_initTrackMathCoreDict G__cpp_setup_initializerTrackMathCoreDict;

